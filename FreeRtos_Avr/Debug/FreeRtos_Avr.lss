
FreeRtos_Avr.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d96  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00002d96  00002e2a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f9  0080006e  0080006e  00002e38  2**0
                  ALLOC
  3 .stab         000047b8  00000000  00000000  00002e38  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003008  00000000  00000000  000075f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e9       	ldi	r30, 0x96	; 150
      68:	fd e2       	ldi	r31, 0x2D	; 45
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 36       	cpi	r26, 0x67	; 103
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <main>
      8a:	0c 94 c9 16 	jmp	0x2d92	; 0x2d92 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <M_DIO_void_setPinDir>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	2d 97       	sbiw	r28, 0x0d	; 13
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	89 83       	std	Y+1, r24	; 0x01
      a8:	6a 83       	std	Y+2, r22	; 0x02
      aa:	4b 83       	std	Y+3, r20	; 0x03
      ac:	89 81       	ldd	r24, Y+1	; 0x01
      ae:	28 2f       	mov	r18, r24
      b0:	30 e0       	ldi	r19, 0x00	; 0
      b2:	3d 87       	std	Y+13, r19	; 0x0d
      b4:	2c 87       	std	Y+12, r18	; 0x0c
      b6:	8c 85       	ldd	r24, Y+12	; 0x0c
      b8:	9d 85       	ldd	r25, Y+13	; 0x0d
      ba:	82 30       	cpi	r24, 0x02	; 2
      bc:	91 05       	cpc	r25, r1
      be:	09 f4       	brne	.+2      	; 0xc2 <M_DIO_void_setPinDir+0x30>
      c0:	50 c0       	rjmp	.+160    	; 0x162 <M_DIO_void_setPinDir+0xd0>
      c2:	2c 85       	ldd	r18, Y+12	; 0x0c
      c4:	3d 85       	ldd	r19, Y+13	; 0x0d
      c6:	23 30       	cpi	r18, 0x03	; 3
      c8:	31 05       	cpc	r19, r1
      ca:	34 f4       	brge	.+12     	; 0xd8 <M_DIO_void_setPinDir+0x46>
      cc:	8c 85       	ldd	r24, Y+12	; 0x0c
      ce:	9d 85       	ldd	r25, Y+13	; 0x0d
      d0:	81 30       	cpi	r24, 0x01	; 1
      d2:	91 05       	cpc	r25, r1
      d4:	71 f0       	breq	.+28     	; 0xf2 <M_DIO_void_setPinDir+0x60>
      d6:	ec c0       	rjmp	.+472    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
      d8:	2c 85       	ldd	r18, Y+12	; 0x0c
      da:	3d 85       	ldd	r19, Y+13	; 0x0d
      dc:	23 30       	cpi	r18, 0x03	; 3
      de:	31 05       	cpc	r19, r1
      e0:	09 f4       	brne	.+2      	; 0xe4 <M_DIO_void_setPinDir+0x52>
      e2:	77 c0       	rjmp	.+238    	; 0x1d2 <M_DIO_void_setPinDir+0x140>
      e4:	8c 85       	ldd	r24, Y+12	; 0x0c
      e6:	9d 85       	ldd	r25, Y+13	; 0x0d
      e8:	84 30       	cpi	r24, 0x04	; 4
      ea:	91 05       	cpc	r25, r1
      ec:	09 f4       	brne	.+2      	; 0xf0 <M_DIO_void_setPinDir+0x5e>
      ee:	a9 c0       	rjmp	.+338    	; 0x242 <M_DIO_void_setPinDir+0x1b0>
      f0:	df c0       	rjmp	.+446    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
      f2:	8b 81       	ldd	r24, Y+3	; 0x03
      f4:	28 2f       	mov	r18, r24
      f6:	30 e0       	ldi	r19, 0x00	; 0
      f8:	3b 87       	std	Y+11, r19	; 0x0b
      fa:	2a 87       	std	Y+10, r18	; 0x0a
      fc:	8a 85       	ldd	r24, Y+10	; 0x0a
      fe:	9b 85       	ldd	r25, Y+11	; 0x0b
     100:	00 97       	sbiw	r24, 0x00	; 0
     102:	31 f0       	breq	.+12     	; 0x110 <M_DIO_void_setPinDir+0x7e>
     104:	2a 85       	ldd	r18, Y+10	; 0x0a
     106:	3b 85       	ldd	r19, Y+11	; 0x0b
     108:	21 30       	cpi	r18, 0x01	; 1
     10a:	31 05       	cpc	r19, r1
     10c:	b1 f0       	breq	.+44     	; 0x13a <M_DIO_void_setPinDir+0xa8>
     10e:	d0 c0       	rjmp	.+416    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     110:	aa e3       	ldi	r26, 0x3A	; 58
     112:	b0 e0       	ldi	r27, 0x00	; 0
     114:	ea e3       	ldi	r30, 0x3A	; 58
     116:	f0 e0       	ldi	r31, 0x00	; 0
     118:	80 81       	ld	r24, Z
     11a:	48 2f       	mov	r20, r24
     11c:	8a 81       	ldd	r24, Y+2	; 0x02
     11e:	28 2f       	mov	r18, r24
     120:	30 e0       	ldi	r19, 0x00	; 0
     122:	81 e0       	ldi	r24, 0x01	; 1
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	02 2e       	mov	r0, r18
     128:	02 c0       	rjmp	.+4      	; 0x12e <M_DIO_void_setPinDir+0x9c>
     12a:	88 0f       	add	r24, r24
     12c:	99 1f       	adc	r25, r25
     12e:	0a 94       	dec	r0
     130:	e2 f7       	brpl	.-8      	; 0x12a <M_DIO_void_setPinDir+0x98>
     132:	80 95       	com	r24
     134:	84 23       	and	r24, r20
     136:	8c 93       	st	X, r24
     138:	bb c0       	rjmp	.+374    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     13a:	aa e3       	ldi	r26, 0x3A	; 58
     13c:	b0 e0       	ldi	r27, 0x00	; 0
     13e:	ea e3       	ldi	r30, 0x3A	; 58
     140:	f0 e0       	ldi	r31, 0x00	; 0
     142:	80 81       	ld	r24, Z
     144:	48 2f       	mov	r20, r24
     146:	8a 81       	ldd	r24, Y+2	; 0x02
     148:	28 2f       	mov	r18, r24
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	81 e0       	ldi	r24, 0x01	; 1
     14e:	90 e0       	ldi	r25, 0x00	; 0
     150:	02 2e       	mov	r0, r18
     152:	02 c0       	rjmp	.+4      	; 0x158 <M_DIO_void_setPinDir+0xc6>
     154:	88 0f       	add	r24, r24
     156:	99 1f       	adc	r25, r25
     158:	0a 94       	dec	r0
     15a:	e2 f7       	brpl	.-8      	; 0x154 <M_DIO_void_setPinDir+0xc2>
     15c:	84 2b       	or	r24, r20
     15e:	8c 93       	st	X, r24
     160:	a7 c0       	rjmp	.+334    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     162:	8b 81       	ldd	r24, Y+3	; 0x03
     164:	28 2f       	mov	r18, r24
     166:	30 e0       	ldi	r19, 0x00	; 0
     168:	39 87       	std	Y+9, r19	; 0x09
     16a:	28 87       	std	Y+8, r18	; 0x08
     16c:	88 85       	ldd	r24, Y+8	; 0x08
     16e:	99 85       	ldd	r25, Y+9	; 0x09
     170:	00 97       	sbiw	r24, 0x00	; 0
     172:	31 f0       	breq	.+12     	; 0x180 <M_DIO_void_setPinDir+0xee>
     174:	28 85       	ldd	r18, Y+8	; 0x08
     176:	39 85       	ldd	r19, Y+9	; 0x09
     178:	21 30       	cpi	r18, 0x01	; 1
     17a:	31 05       	cpc	r19, r1
     17c:	b1 f0       	breq	.+44     	; 0x1aa <M_DIO_void_setPinDir+0x118>
     17e:	98 c0       	rjmp	.+304    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     180:	a7 e3       	ldi	r26, 0x37	; 55
     182:	b0 e0       	ldi	r27, 0x00	; 0
     184:	e7 e3       	ldi	r30, 0x37	; 55
     186:	f0 e0       	ldi	r31, 0x00	; 0
     188:	80 81       	ld	r24, Z
     18a:	48 2f       	mov	r20, r24
     18c:	8a 81       	ldd	r24, Y+2	; 0x02
     18e:	28 2f       	mov	r18, r24
     190:	30 e0       	ldi	r19, 0x00	; 0
     192:	81 e0       	ldi	r24, 0x01	; 1
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	02 2e       	mov	r0, r18
     198:	02 c0       	rjmp	.+4      	; 0x19e <M_DIO_void_setPinDir+0x10c>
     19a:	88 0f       	add	r24, r24
     19c:	99 1f       	adc	r25, r25
     19e:	0a 94       	dec	r0
     1a0:	e2 f7       	brpl	.-8      	; 0x19a <M_DIO_void_setPinDir+0x108>
     1a2:	80 95       	com	r24
     1a4:	84 23       	and	r24, r20
     1a6:	8c 93       	st	X, r24
     1a8:	83 c0       	rjmp	.+262    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     1aa:	a7 e3       	ldi	r26, 0x37	; 55
     1ac:	b0 e0       	ldi	r27, 0x00	; 0
     1ae:	e7 e3       	ldi	r30, 0x37	; 55
     1b0:	f0 e0       	ldi	r31, 0x00	; 0
     1b2:	80 81       	ld	r24, Z
     1b4:	48 2f       	mov	r20, r24
     1b6:	8a 81       	ldd	r24, Y+2	; 0x02
     1b8:	28 2f       	mov	r18, r24
     1ba:	30 e0       	ldi	r19, 0x00	; 0
     1bc:	81 e0       	ldi	r24, 0x01	; 1
     1be:	90 e0       	ldi	r25, 0x00	; 0
     1c0:	02 2e       	mov	r0, r18
     1c2:	02 c0       	rjmp	.+4      	; 0x1c8 <M_DIO_void_setPinDir+0x136>
     1c4:	88 0f       	add	r24, r24
     1c6:	99 1f       	adc	r25, r25
     1c8:	0a 94       	dec	r0
     1ca:	e2 f7       	brpl	.-8      	; 0x1c4 <M_DIO_void_setPinDir+0x132>
     1cc:	84 2b       	or	r24, r20
     1ce:	8c 93       	st	X, r24
     1d0:	6f c0       	rjmp	.+222    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     1d2:	8b 81       	ldd	r24, Y+3	; 0x03
     1d4:	28 2f       	mov	r18, r24
     1d6:	30 e0       	ldi	r19, 0x00	; 0
     1d8:	3f 83       	std	Y+7, r19	; 0x07
     1da:	2e 83       	std	Y+6, r18	; 0x06
     1dc:	8e 81       	ldd	r24, Y+6	; 0x06
     1de:	9f 81       	ldd	r25, Y+7	; 0x07
     1e0:	00 97       	sbiw	r24, 0x00	; 0
     1e2:	31 f0       	breq	.+12     	; 0x1f0 <M_DIO_void_setPinDir+0x15e>
     1e4:	2e 81       	ldd	r18, Y+6	; 0x06
     1e6:	3f 81       	ldd	r19, Y+7	; 0x07
     1e8:	21 30       	cpi	r18, 0x01	; 1
     1ea:	31 05       	cpc	r19, r1
     1ec:	b1 f0       	breq	.+44     	; 0x21a <M_DIO_void_setPinDir+0x188>
     1ee:	60 c0       	rjmp	.+192    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     1f0:	a4 e3       	ldi	r26, 0x34	; 52
     1f2:	b0 e0       	ldi	r27, 0x00	; 0
     1f4:	e4 e3       	ldi	r30, 0x34	; 52
     1f6:	f0 e0       	ldi	r31, 0x00	; 0
     1f8:	80 81       	ld	r24, Z
     1fa:	48 2f       	mov	r20, r24
     1fc:	8a 81       	ldd	r24, Y+2	; 0x02
     1fe:	28 2f       	mov	r18, r24
     200:	30 e0       	ldi	r19, 0x00	; 0
     202:	81 e0       	ldi	r24, 0x01	; 1
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	02 2e       	mov	r0, r18
     208:	02 c0       	rjmp	.+4      	; 0x20e <M_DIO_void_setPinDir+0x17c>
     20a:	88 0f       	add	r24, r24
     20c:	99 1f       	adc	r25, r25
     20e:	0a 94       	dec	r0
     210:	e2 f7       	brpl	.-8      	; 0x20a <M_DIO_void_setPinDir+0x178>
     212:	80 95       	com	r24
     214:	84 23       	and	r24, r20
     216:	8c 93       	st	X, r24
     218:	4b c0       	rjmp	.+150    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     21a:	a4 e3       	ldi	r26, 0x34	; 52
     21c:	b0 e0       	ldi	r27, 0x00	; 0
     21e:	e4 e3       	ldi	r30, 0x34	; 52
     220:	f0 e0       	ldi	r31, 0x00	; 0
     222:	80 81       	ld	r24, Z
     224:	48 2f       	mov	r20, r24
     226:	8a 81       	ldd	r24, Y+2	; 0x02
     228:	28 2f       	mov	r18, r24
     22a:	30 e0       	ldi	r19, 0x00	; 0
     22c:	81 e0       	ldi	r24, 0x01	; 1
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	02 2e       	mov	r0, r18
     232:	02 c0       	rjmp	.+4      	; 0x238 <M_DIO_void_setPinDir+0x1a6>
     234:	88 0f       	add	r24, r24
     236:	99 1f       	adc	r25, r25
     238:	0a 94       	dec	r0
     23a:	e2 f7       	brpl	.-8      	; 0x234 <M_DIO_void_setPinDir+0x1a2>
     23c:	84 2b       	or	r24, r20
     23e:	8c 93       	st	X, r24
     240:	37 c0       	rjmp	.+110    	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     242:	8b 81       	ldd	r24, Y+3	; 0x03
     244:	28 2f       	mov	r18, r24
     246:	30 e0       	ldi	r19, 0x00	; 0
     248:	3d 83       	std	Y+5, r19	; 0x05
     24a:	2c 83       	std	Y+4, r18	; 0x04
     24c:	8c 81       	ldd	r24, Y+4	; 0x04
     24e:	9d 81       	ldd	r25, Y+5	; 0x05
     250:	00 97       	sbiw	r24, 0x00	; 0
     252:	31 f0       	breq	.+12     	; 0x260 <M_DIO_void_setPinDir+0x1ce>
     254:	2c 81       	ldd	r18, Y+4	; 0x04
     256:	3d 81       	ldd	r19, Y+5	; 0x05
     258:	21 30       	cpi	r18, 0x01	; 1
     25a:	31 05       	cpc	r19, r1
     25c:	b1 f0       	breq	.+44     	; 0x28a <M_DIO_void_setPinDir+0x1f8>
     25e:	28 c0       	rjmp	.+80     	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     260:	a1 e3       	ldi	r26, 0x31	; 49
     262:	b0 e0       	ldi	r27, 0x00	; 0
     264:	e1 e3       	ldi	r30, 0x31	; 49
     266:	f0 e0       	ldi	r31, 0x00	; 0
     268:	80 81       	ld	r24, Z
     26a:	48 2f       	mov	r20, r24
     26c:	8a 81       	ldd	r24, Y+2	; 0x02
     26e:	28 2f       	mov	r18, r24
     270:	30 e0       	ldi	r19, 0x00	; 0
     272:	81 e0       	ldi	r24, 0x01	; 1
     274:	90 e0       	ldi	r25, 0x00	; 0
     276:	02 2e       	mov	r0, r18
     278:	02 c0       	rjmp	.+4      	; 0x27e <M_DIO_void_setPinDir+0x1ec>
     27a:	88 0f       	add	r24, r24
     27c:	99 1f       	adc	r25, r25
     27e:	0a 94       	dec	r0
     280:	e2 f7       	brpl	.-8      	; 0x27a <M_DIO_void_setPinDir+0x1e8>
     282:	80 95       	com	r24
     284:	84 23       	and	r24, r20
     286:	8c 93       	st	X, r24
     288:	13 c0       	rjmp	.+38     	; 0x2b0 <M_DIO_void_setPinDir+0x21e>
     28a:	a1 e3       	ldi	r26, 0x31	; 49
     28c:	b0 e0       	ldi	r27, 0x00	; 0
     28e:	e1 e3       	ldi	r30, 0x31	; 49
     290:	f0 e0       	ldi	r31, 0x00	; 0
     292:	80 81       	ld	r24, Z
     294:	48 2f       	mov	r20, r24
     296:	8a 81       	ldd	r24, Y+2	; 0x02
     298:	28 2f       	mov	r18, r24
     29a:	30 e0       	ldi	r19, 0x00	; 0
     29c:	81 e0       	ldi	r24, 0x01	; 1
     29e:	90 e0       	ldi	r25, 0x00	; 0
     2a0:	02 2e       	mov	r0, r18
     2a2:	02 c0       	rjmp	.+4      	; 0x2a8 <M_DIO_void_setPinDir+0x216>
     2a4:	88 0f       	add	r24, r24
     2a6:	99 1f       	adc	r25, r25
     2a8:	0a 94       	dec	r0
     2aa:	e2 f7       	brpl	.-8      	; 0x2a4 <M_DIO_void_setPinDir+0x212>
     2ac:	84 2b       	or	r24, r20
     2ae:	8c 93       	st	X, r24
     2b0:	2d 96       	adiw	r28, 0x0d	; 13
     2b2:	0f b6       	in	r0, 0x3f	; 63
     2b4:	f8 94       	cli
     2b6:	de bf       	out	0x3e, r29	; 62
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	cd bf       	out	0x3d, r28	; 61
     2bc:	cf 91       	pop	r28
     2be:	df 91       	pop	r29
     2c0:	08 95       	ret

000002c2 <M_DIO_void_setPinValue>:
				}
				break;
	}
}
void M_DIO_void_setPinValue(u8 Port, u8 Pin, VALUE_T value)
{
     2c2:	df 93       	push	r29
     2c4:	cf 93       	push	r28
     2c6:	cd b7       	in	r28, 0x3d	; 61
     2c8:	de b7       	in	r29, 0x3e	; 62
     2ca:	2d 97       	sbiw	r28, 0x0d	; 13
     2cc:	0f b6       	in	r0, 0x3f	; 63
     2ce:	f8 94       	cli
     2d0:	de bf       	out	0x3e, r29	; 62
     2d2:	0f be       	out	0x3f, r0	; 63
     2d4:	cd bf       	out	0x3d, r28	; 61
     2d6:	89 83       	std	Y+1, r24	; 0x01
     2d8:	6a 83       	std	Y+2, r22	; 0x02
     2da:	4b 83       	std	Y+3, r20	; 0x03
	switch (Port)
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	28 2f       	mov	r18, r24
     2e0:	30 e0       	ldi	r19, 0x00	; 0
     2e2:	3d 87       	std	Y+13, r19	; 0x0d
     2e4:	2c 87       	std	Y+12, r18	; 0x0c
     2e6:	8c 85       	ldd	r24, Y+12	; 0x0c
     2e8:	9d 85       	ldd	r25, Y+13	; 0x0d
     2ea:	82 30       	cpi	r24, 0x02	; 2
     2ec:	91 05       	cpc	r25, r1
     2ee:	09 f4       	brne	.+2      	; 0x2f2 <M_DIO_void_setPinValue+0x30>
     2f0:	50 c0       	rjmp	.+160    	; 0x392 <M_DIO_void_setPinValue+0xd0>
     2f2:	2c 85       	ldd	r18, Y+12	; 0x0c
     2f4:	3d 85       	ldd	r19, Y+13	; 0x0d
     2f6:	23 30       	cpi	r18, 0x03	; 3
     2f8:	31 05       	cpc	r19, r1
     2fa:	34 f4       	brge	.+12     	; 0x308 <M_DIO_void_setPinValue+0x46>
     2fc:	8c 85       	ldd	r24, Y+12	; 0x0c
     2fe:	9d 85       	ldd	r25, Y+13	; 0x0d
     300:	81 30       	cpi	r24, 0x01	; 1
     302:	91 05       	cpc	r25, r1
     304:	71 f0       	breq	.+28     	; 0x322 <M_DIO_void_setPinValue+0x60>
     306:	ec c0       	rjmp	.+472    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
     308:	2c 85       	ldd	r18, Y+12	; 0x0c
     30a:	3d 85       	ldd	r19, Y+13	; 0x0d
     30c:	23 30       	cpi	r18, 0x03	; 3
     30e:	31 05       	cpc	r19, r1
     310:	09 f4       	brne	.+2      	; 0x314 <M_DIO_void_setPinValue+0x52>
     312:	77 c0       	rjmp	.+238    	; 0x402 <M_DIO_void_setPinValue+0x140>
     314:	8c 85       	ldd	r24, Y+12	; 0x0c
     316:	9d 85       	ldd	r25, Y+13	; 0x0d
     318:	84 30       	cpi	r24, 0x04	; 4
     31a:	91 05       	cpc	r25, r1
     31c:	09 f4       	brne	.+2      	; 0x320 <M_DIO_void_setPinValue+0x5e>
     31e:	a9 c0       	rjmp	.+338    	; 0x472 <M_DIO_void_setPinValue+0x1b0>
     320:	df c0       	rjmp	.+446    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
		{
		case PORTA_ID :
			switch (value)
     322:	8b 81       	ldd	r24, Y+3	; 0x03
     324:	28 2f       	mov	r18, r24
     326:	30 e0       	ldi	r19, 0x00	; 0
     328:	3b 87       	std	Y+11, r19	; 0x0b
     32a:	2a 87       	std	Y+10, r18	; 0x0a
     32c:	8a 85       	ldd	r24, Y+10	; 0x0a
     32e:	9b 85       	ldd	r25, Y+11	; 0x0b
     330:	00 97       	sbiw	r24, 0x00	; 0
     332:	31 f0       	breq	.+12     	; 0x340 <M_DIO_void_setPinValue+0x7e>
     334:	2a 85       	ldd	r18, Y+10	; 0x0a
     336:	3b 85       	ldd	r19, Y+11	; 0x0b
     338:	21 30       	cpi	r18, 0x01	; 1
     33a:	31 05       	cpc	r19, r1
     33c:	b1 f0       	breq	.+44     	; 0x36a <M_DIO_void_setPinValue+0xa8>
     33e:	d0 c0       	rjmp	.+416    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
			{
			case LOW:
				 CLR_BIT(PORTA_REG,Pin);
     340:	ab e3       	ldi	r26, 0x3B	; 59
     342:	b0 e0       	ldi	r27, 0x00	; 0
     344:	eb e3       	ldi	r30, 0x3B	; 59
     346:	f0 e0       	ldi	r31, 0x00	; 0
     348:	80 81       	ld	r24, Z
     34a:	48 2f       	mov	r20, r24
     34c:	8a 81       	ldd	r24, Y+2	; 0x02
     34e:	28 2f       	mov	r18, r24
     350:	30 e0       	ldi	r19, 0x00	; 0
     352:	81 e0       	ldi	r24, 0x01	; 1
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	02 2e       	mov	r0, r18
     358:	02 c0       	rjmp	.+4      	; 0x35e <M_DIO_void_setPinValue+0x9c>
     35a:	88 0f       	add	r24, r24
     35c:	99 1f       	adc	r25, r25
     35e:	0a 94       	dec	r0
     360:	e2 f7       	brpl	.-8      	; 0x35a <M_DIO_void_setPinValue+0x98>
     362:	80 95       	com	r24
     364:	84 23       	and	r24, r20
     366:	8c 93       	st	X, r24
     368:	bb c0       	rjmp	.+374    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
				 break;
			case HIGH:
				SET_BIT(PORTA_REG,Pin);
     36a:	ab e3       	ldi	r26, 0x3B	; 59
     36c:	b0 e0       	ldi	r27, 0x00	; 0
     36e:	eb e3       	ldi	r30, 0x3B	; 59
     370:	f0 e0       	ldi	r31, 0x00	; 0
     372:	80 81       	ld	r24, Z
     374:	48 2f       	mov	r20, r24
     376:	8a 81       	ldd	r24, Y+2	; 0x02
     378:	28 2f       	mov	r18, r24
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	81 e0       	ldi	r24, 0x01	; 1
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	02 2e       	mov	r0, r18
     382:	02 c0       	rjmp	.+4      	; 0x388 <M_DIO_void_setPinValue+0xc6>
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	0a 94       	dec	r0
     38a:	e2 f7       	brpl	.-8      	; 0x384 <M_DIO_void_setPinValue+0xc2>
     38c:	84 2b       	or	r24, r20
     38e:	8c 93       	st	X, r24
     390:	a7 c0       	rjmp	.+334    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
				break;
		   }
			break;
		case PORTB_ID :
			switch (value)
     392:	8b 81       	ldd	r24, Y+3	; 0x03
     394:	28 2f       	mov	r18, r24
     396:	30 e0       	ldi	r19, 0x00	; 0
     398:	39 87       	std	Y+9, r19	; 0x09
     39a:	28 87       	std	Y+8, r18	; 0x08
     39c:	88 85       	ldd	r24, Y+8	; 0x08
     39e:	99 85       	ldd	r25, Y+9	; 0x09
     3a0:	00 97       	sbiw	r24, 0x00	; 0
     3a2:	31 f0       	breq	.+12     	; 0x3b0 <M_DIO_void_setPinValue+0xee>
     3a4:	28 85       	ldd	r18, Y+8	; 0x08
     3a6:	39 85       	ldd	r19, Y+9	; 0x09
     3a8:	21 30       	cpi	r18, 0x01	; 1
     3aa:	31 05       	cpc	r19, r1
     3ac:	b1 f0       	breq	.+44     	; 0x3da <M_DIO_void_setPinValue+0x118>
     3ae:	98 c0       	rjmp	.+304    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
			{
			case LOW:
				 CLR_BIT(PORTB_REG,Pin);
     3b0:	a8 e3       	ldi	r26, 0x38	; 56
     3b2:	b0 e0       	ldi	r27, 0x00	; 0
     3b4:	e8 e3       	ldi	r30, 0x38	; 56
     3b6:	f0 e0       	ldi	r31, 0x00	; 0
     3b8:	80 81       	ld	r24, Z
     3ba:	48 2f       	mov	r20, r24
     3bc:	8a 81       	ldd	r24, Y+2	; 0x02
     3be:	28 2f       	mov	r18, r24
     3c0:	30 e0       	ldi	r19, 0x00	; 0
     3c2:	81 e0       	ldi	r24, 0x01	; 1
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	02 2e       	mov	r0, r18
     3c8:	02 c0       	rjmp	.+4      	; 0x3ce <M_DIO_void_setPinValue+0x10c>
     3ca:	88 0f       	add	r24, r24
     3cc:	99 1f       	adc	r25, r25
     3ce:	0a 94       	dec	r0
     3d0:	e2 f7       	brpl	.-8      	; 0x3ca <M_DIO_void_setPinValue+0x108>
     3d2:	80 95       	com	r24
     3d4:	84 23       	and	r24, r20
     3d6:	8c 93       	st	X, r24
     3d8:	83 c0       	rjmp	.+262    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
				 break;
			case HIGH:
				 SET_BIT(PORTB_REG,Pin);
     3da:	a8 e3       	ldi	r26, 0x38	; 56
     3dc:	b0 e0       	ldi	r27, 0x00	; 0
     3de:	e8 e3       	ldi	r30, 0x38	; 56
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	80 81       	ld	r24, Z
     3e4:	48 2f       	mov	r20, r24
     3e6:	8a 81       	ldd	r24, Y+2	; 0x02
     3e8:	28 2f       	mov	r18, r24
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	81 e0       	ldi	r24, 0x01	; 1
     3ee:	90 e0       	ldi	r25, 0x00	; 0
     3f0:	02 2e       	mov	r0, r18
     3f2:	02 c0       	rjmp	.+4      	; 0x3f8 <M_DIO_void_setPinValue+0x136>
     3f4:	88 0f       	add	r24, r24
     3f6:	99 1f       	adc	r25, r25
     3f8:	0a 94       	dec	r0
     3fa:	e2 f7       	brpl	.-8      	; 0x3f4 <M_DIO_void_setPinValue+0x132>
     3fc:	84 2b       	or	r24, r20
     3fe:	8c 93       	st	X, r24
     400:	6f c0       	rjmp	.+222    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
				 break;
			}
			break;
		case PORTC_ID:
			switch (value)
     402:	8b 81       	ldd	r24, Y+3	; 0x03
     404:	28 2f       	mov	r18, r24
     406:	30 e0       	ldi	r19, 0x00	; 0
     408:	3f 83       	std	Y+7, r19	; 0x07
     40a:	2e 83       	std	Y+6, r18	; 0x06
     40c:	8e 81       	ldd	r24, Y+6	; 0x06
     40e:	9f 81       	ldd	r25, Y+7	; 0x07
     410:	00 97       	sbiw	r24, 0x00	; 0
     412:	31 f0       	breq	.+12     	; 0x420 <M_DIO_void_setPinValue+0x15e>
     414:	2e 81       	ldd	r18, Y+6	; 0x06
     416:	3f 81       	ldd	r19, Y+7	; 0x07
     418:	21 30       	cpi	r18, 0x01	; 1
     41a:	31 05       	cpc	r19, r1
     41c:	b1 f0       	breq	.+44     	; 0x44a <M_DIO_void_setPinValue+0x188>
     41e:	60 c0       	rjmp	.+192    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
			{
			case LOW:
				 CLR_BIT(PORTC_REG,Pin);
     420:	a5 e3       	ldi	r26, 0x35	; 53
     422:	b0 e0       	ldi	r27, 0x00	; 0
     424:	e5 e3       	ldi	r30, 0x35	; 53
     426:	f0 e0       	ldi	r31, 0x00	; 0
     428:	80 81       	ld	r24, Z
     42a:	48 2f       	mov	r20, r24
     42c:	8a 81       	ldd	r24, Y+2	; 0x02
     42e:	28 2f       	mov	r18, r24
     430:	30 e0       	ldi	r19, 0x00	; 0
     432:	81 e0       	ldi	r24, 0x01	; 1
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	02 2e       	mov	r0, r18
     438:	02 c0       	rjmp	.+4      	; 0x43e <M_DIO_void_setPinValue+0x17c>
     43a:	88 0f       	add	r24, r24
     43c:	99 1f       	adc	r25, r25
     43e:	0a 94       	dec	r0
     440:	e2 f7       	brpl	.-8      	; 0x43a <M_DIO_void_setPinValue+0x178>
     442:	80 95       	com	r24
     444:	84 23       	and	r24, r20
     446:	8c 93       	st	X, r24
     448:	4b c0       	rjmp	.+150    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
				break;
			case HIGH:
				 SET_BIT(PORTC_REG,Pin);
     44a:	a5 e3       	ldi	r26, 0x35	; 53
     44c:	b0 e0       	ldi	r27, 0x00	; 0
     44e:	e5 e3       	ldi	r30, 0x35	; 53
     450:	f0 e0       	ldi	r31, 0x00	; 0
     452:	80 81       	ld	r24, Z
     454:	48 2f       	mov	r20, r24
     456:	8a 81       	ldd	r24, Y+2	; 0x02
     458:	28 2f       	mov	r18, r24
     45a:	30 e0       	ldi	r19, 0x00	; 0
     45c:	81 e0       	ldi	r24, 0x01	; 1
     45e:	90 e0       	ldi	r25, 0x00	; 0
     460:	02 2e       	mov	r0, r18
     462:	02 c0       	rjmp	.+4      	; 0x468 <M_DIO_void_setPinValue+0x1a6>
     464:	88 0f       	add	r24, r24
     466:	99 1f       	adc	r25, r25
     468:	0a 94       	dec	r0
     46a:	e2 f7       	brpl	.-8      	; 0x464 <M_DIO_void_setPinValue+0x1a2>
     46c:	84 2b       	or	r24, r20
     46e:	8c 93       	st	X, r24
     470:	37 c0       	rjmp	.+110    	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
				break;
			}
			break;
		case PORTD_ID :
			 switch (value)
     472:	8b 81       	ldd	r24, Y+3	; 0x03
     474:	28 2f       	mov	r18, r24
     476:	30 e0       	ldi	r19, 0x00	; 0
     478:	3d 83       	std	Y+5, r19	; 0x05
     47a:	2c 83       	std	Y+4, r18	; 0x04
     47c:	8c 81       	ldd	r24, Y+4	; 0x04
     47e:	9d 81       	ldd	r25, Y+5	; 0x05
     480:	00 97       	sbiw	r24, 0x00	; 0
     482:	31 f0       	breq	.+12     	; 0x490 <M_DIO_void_setPinValue+0x1ce>
     484:	2c 81       	ldd	r18, Y+4	; 0x04
     486:	3d 81       	ldd	r19, Y+5	; 0x05
     488:	21 30       	cpi	r18, 0x01	; 1
     48a:	31 05       	cpc	r19, r1
     48c:	b1 f0       	breq	.+44     	; 0x4ba <M_DIO_void_setPinValue+0x1f8>
     48e:	28 c0       	rjmp	.+80     	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
			 {
				case LOW:
				   CLR_BIT(PORTD_REG,Pin);
     490:	a2 e3       	ldi	r26, 0x32	; 50
     492:	b0 e0       	ldi	r27, 0x00	; 0
     494:	e2 e3       	ldi	r30, 0x32	; 50
     496:	f0 e0       	ldi	r31, 0x00	; 0
     498:	80 81       	ld	r24, Z
     49a:	48 2f       	mov	r20, r24
     49c:	8a 81       	ldd	r24, Y+2	; 0x02
     49e:	28 2f       	mov	r18, r24
     4a0:	30 e0       	ldi	r19, 0x00	; 0
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	02 2e       	mov	r0, r18
     4a8:	02 c0       	rjmp	.+4      	; 0x4ae <M_DIO_void_setPinValue+0x1ec>
     4aa:	88 0f       	add	r24, r24
     4ac:	99 1f       	adc	r25, r25
     4ae:	0a 94       	dec	r0
     4b0:	e2 f7       	brpl	.-8      	; 0x4aa <M_DIO_void_setPinValue+0x1e8>
     4b2:	80 95       	com	r24
     4b4:	84 23       	and	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	13 c0       	rjmp	.+38     	; 0x4e0 <M_DIO_void_setPinValue+0x21e>
					break;
				case HIGH:
					SET_BIT(PORTD_REG,Pin);
     4ba:	a2 e3       	ldi	r26, 0x32	; 50
     4bc:	b0 e0       	ldi	r27, 0x00	; 0
     4be:	e2 e3       	ldi	r30, 0x32	; 50
     4c0:	f0 e0       	ldi	r31, 0x00	; 0
     4c2:	80 81       	ld	r24, Z
     4c4:	48 2f       	mov	r20, r24
     4c6:	8a 81       	ldd	r24, Y+2	; 0x02
     4c8:	28 2f       	mov	r18, r24
     4ca:	30 e0       	ldi	r19, 0x00	; 0
     4cc:	81 e0       	ldi	r24, 0x01	; 1
     4ce:	90 e0       	ldi	r25, 0x00	; 0
     4d0:	02 2e       	mov	r0, r18
     4d2:	02 c0       	rjmp	.+4      	; 0x4d8 <M_DIO_void_setPinValue+0x216>
     4d4:	88 0f       	add	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	0a 94       	dec	r0
     4da:	e2 f7       	brpl	.-8      	; 0x4d4 <M_DIO_void_setPinValue+0x212>
     4dc:	84 2b       	or	r24, r20
     4de:	8c 93       	st	X, r24
					break;
			 }
			 break;
		}
}
     4e0:	2d 96       	adiw	r28, 0x0d	; 13
     4e2:	0f b6       	in	r0, 0x3f	; 63
     4e4:	f8 94       	cli
     4e6:	de bf       	out	0x3e, r29	; 62
     4e8:	0f be       	out	0x3f, r0	; 63
     4ea:	cd bf       	out	0x3d, r28	; 61
     4ec:	cf 91       	pop	r28
     4ee:	df 91       	pop	r29
     4f0:	08 95       	ret

000004f2 <M_DIO_void_getPinValue>:
void M_DIO_void_getPinValue(u8 Port, u8 Pin, u8 *pvalue)
{
     4f2:	df 93       	push	r29
     4f4:	cf 93       	push	r28
     4f6:	00 d0       	rcall	.+0      	; 0x4f8 <M_DIO_void_getPinValue+0x6>
     4f8:	00 d0       	rcall	.+0      	; 0x4fa <M_DIO_void_getPinValue+0x8>
     4fa:	00 d0       	rcall	.+0      	; 0x4fc <M_DIO_void_getPinValue+0xa>
     4fc:	cd b7       	in	r28, 0x3d	; 61
     4fe:	de b7       	in	r29, 0x3e	; 62
     500:	89 83       	std	Y+1, r24	; 0x01
     502:	6a 83       	std	Y+2, r22	; 0x02
     504:	5c 83       	std	Y+4, r21	; 0x04
     506:	4b 83       	std	Y+3, r20	; 0x03
	switch (Port){
     508:	89 81       	ldd	r24, Y+1	; 0x01
     50a:	28 2f       	mov	r18, r24
     50c:	30 e0       	ldi	r19, 0x00	; 0
     50e:	3e 83       	std	Y+6, r19	; 0x06
     510:	2d 83       	std	Y+5, r18	; 0x05
     512:	4d 81       	ldd	r20, Y+5	; 0x05
     514:	5e 81       	ldd	r21, Y+6	; 0x06
     516:	42 30       	cpi	r20, 0x02	; 2
     518:	51 05       	cpc	r21, r1
     51a:	59 f1       	breq	.+86     	; 0x572 <M_DIO_void_getPinValue+0x80>
     51c:	8d 81       	ldd	r24, Y+5	; 0x05
     51e:	9e 81       	ldd	r25, Y+6	; 0x06
     520:	83 30       	cpi	r24, 0x03	; 3
     522:	91 05       	cpc	r25, r1
     524:	34 f4       	brge	.+12     	; 0x532 <M_DIO_void_getPinValue+0x40>
     526:	2d 81       	ldd	r18, Y+5	; 0x05
     528:	3e 81       	ldd	r19, Y+6	; 0x06
     52a:	21 30       	cpi	r18, 0x01	; 1
     52c:	31 05       	cpc	r19, r1
     52e:	69 f0       	breq	.+26     	; 0x54a <M_DIO_void_getPinValue+0x58>
     530:	5b c0       	rjmp	.+182    	; 0x5e8 <M_DIO_void_getPinValue+0xf6>
     532:	4d 81       	ldd	r20, Y+5	; 0x05
     534:	5e 81       	ldd	r21, Y+6	; 0x06
     536:	43 30       	cpi	r20, 0x03	; 3
     538:	51 05       	cpc	r21, r1
     53a:	79 f1       	breq	.+94     	; 0x59a <M_DIO_void_getPinValue+0xa8>
     53c:	8d 81       	ldd	r24, Y+5	; 0x05
     53e:	9e 81       	ldd	r25, Y+6	; 0x06
     540:	84 30       	cpi	r24, 0x04	; 4
     542:	91 05       	cpc	r25, r1
     544:	09 f4       	brne	.+2      	; 0x548 <M_DIO_void_getPinValue+0x56>
     546:	3d c0       	rjmp	.+122    	; 0x5c2 <M_DIO_void_getPinValue+0xd0>
     548:	4f c0       	rjmp	.+158    	; 0x5e8 <M_DIO_void_getPinValue+0xf6>
	case PORTA_ID:
		*pvalue = GET_BIT(PINA_REG,Pin);
     54a:	e9 e3       	ldi	r30, 0x39	; 57
     54c:	f0 e0       	ldi	r31, 0x00	; 0
     54e:	80 81       	ld	r24, Z
     550:	28 2f       	mov	r18, r24
     552:	30 e0       	ldi	r19, 0x00	; 0
     554:	8a 81       	ldd	r24, Y+2	; 0x02
     556:	88 2f       	mov	r24, r24
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	a9 01       	movw	r20, r18
     55c:	02 c0       	rjmp	.+4      	; 0x562 <M_DIO_void_getPinValue+0x70>
     55e:	55 95       	asr	r21
     560:	47 95       	ror	r20
     562:	8a 95       	dec	r24
     564:	e2 f7       	brpl	.-8      	; 0x55e <M_DIO_void_getPinValue+0x6c>
     566:	ca 01       	movw	r24, r20
     568:	81 70       	andi	r24, 0x01	; 1
     56a:	eb 81       	ldd	r30, Y+3	; 0x03
     56c:	fc 81       	ldd	r31, Y+4	; 0x04
     56e:	80 83       	st	Z, r24
     570:	3b c0       	rjmp	.+118    	; 0x5e8 <M_DIO_void_getPinValue+0xf6>
		break;
	case PORTB_ID:
		*pvalue=GET_BIT(PINB_REG,Pin);
     572:	e6 e3       	ldi	r30, 0x36	; 54
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	80 81       	ld	r24, Z
     578:	28 2f       	mov	r18, r24
     57a:	30 e0       	ldi	r19, 0x00	; 0
     57c:	8a 81       	ldd	r24, Y+2	; 0x02
     57e:	88 2f       	mov	r24, r24
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	a9 01       	movw	r20, r18
     584:	02 c0       	rjmp	.+4      	; 0x58a <M_DIO_void_getPinValue+0x98>
     586:	55 95       	asr	r21
     588:	47 95       	ror	r20
     58a:	8a 95       	dec	r24
     58c:	e2 f7       	brpl	.-8      	; 0x586 <M_DIO_void_getPinValue+0x94>
     58e:	ca 01       	movw	r24, r20
     590:	81 70       	andi	r24, 0x01	; 1
     592:	eb 81       	ldd	r30, Y+3	; 0x03
     594:	fc 81       	ldd	r31, Y+4	; 0x04
     596:	80 83       	st	Z, r24
     598:	27 c0       	rjmp	.+78     	; 0x5e8 <M_DIO_void_getPinValue+0xf6>
		break;
	case PORTC_ID:
		*pvalue=GET_BIT(PINC_REG,Pin);
     59a:	e3 e3       	ldi	r30, 0x33	; 51
     59c:	f0 e0       	ldi	r31, 0x00	; 0
     59e:	80 81       	ld	r24, Z
     5a0:	28 2f       	mov	r18, r24
     5a2:	30 e0       	ldi	r19, 0x00	; 0
     5a4:	8a 81       	ldd	r24, Y+2	; 0x02
     5a6:	88 2f       	mov	r24, r24
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	a9 01       	movw	r20, r18
     5ac:	02 c0       	rjmp	.+4      	; 0x5b2 <M_DIO_void_getPinValue+0xc0>
     5ae:	55 95       	asr	r21
     5b0:	47 95       	ror	r20
     5b2:	8a 95       	dec	r24
     5b4:	e2 f7       	brpl	.-8      	; 0x5ae <M_DIO_void_getPinValue+0xbc>
     5b6:	ca 01       	movw	r24, r20
     5b8:	81 70       	andi	r24, 0x01	; 1
     5ba:	eb 81       	ldd	r30, Y+3	; 0x03
     5bc:	fc 81       	ldd	r31, Y+4	; 0x04
     5be:	80 83       	st	Z, r24
     5c0:	13 c0       	rjmp	.+38     	; 0x5e8 <M_DIO_void_getPinValue+0xf6>
		break;
	case PORTD_ID:
		*pvalue=GET_BIT(PIND_REG,Pin);
     5c2:	e0 e3       	ldi	r30, 0x30	; 48
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	80 81       	ld	r24, Z
     5c8:	28 2f       	mov	r18, r24
     5ca:	30 e0       	ldi	r19, 0x00	; 0
     5cc:	8a 81       	ldd	r24, Y+2	; 0x02
     5ce:	88 2f       	mov	r24, r24
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	a9 01       	movw	r20, r18
     5d4:	02 c0       	rjmp	.+4      	; 0x5da <M_DIO_void_getPinValue+0xe8>
     5d6:	55 95       	asr	r21
     5d8:	47 95       	ror	r20
     5da:	8a 95       	dec	r24
     5dc:	e2 f7       	brpl	.-8      	; 0x5d6 <M_DIO_void_getPinValue+0xe4>
     5de:	ca 01       	movw	r24, r20
     5e0:	81 70       	andi	r24, 0x01	; 1
     5e2:	eb 81       	ldd	r30, Y+3	; 0x03
     5e4:	fc 81       	ldd	r31, Y+4	; 0x04
     5e6:	80 83       	st	Z, r24
		break;
	}
}
     5e8:	26 96       	adiw	r28, 0x06	; 6
     5ea:	0f b6       	in	r0, 0x3f	; 63
     5ec:	f8 94       	cli
     5ee:	de bf       	out	0x3e, r29	; 62
     5f0:	0f be       	out	0x3f, r0	; 63
     5f2:	cd bf       	out	0x3d, r28	; 61
     5f4:	cf 91       	pop	r28
     5f6:	df 91       	pop	r29
     5f8:	08 95       	ret

000005fa <M_DIO_void_TogPinValue>:
void M_DIO_void_TogPinValue(u8 Port, u8 Pin)
{
     5fa:	df 93       	push	r29
     5fc:	cf 93       	push	r28
     5fe:	00 d0       	rcall	.+0      	; 0x600 <M_DIO_void_TogPinValue+0x6>
     600:	00 d0       	rcall	.+0      	; 0x602 <M_DIO_void_TogPinValue+0x8>
     602:	cd b7       	in	r28, 0x3d	; 61
     604:	de b7       	in	r29, 0x3e	; 62
     606:	89 83       	std	Y+1, r24	; 0x01
     608:	6a 83       	std	Y+2, r22	; 0x02
	switch (Port){
     60a:	89 81       	ldd	r24, Y+1	; 0x01
     60c:	28 2f       	mov	r18, r24
     60e:	30 e0       	ldi	r19, 0x00	; 0
     610:	3c 83       	std	Y+4, r19	; 0x04
     612:	2b 83       	std	Y+3, r18	; 0x03
     614:	8b 81       	ldd	r24, Y+3	; 0x03
     616:	9c 81       	ldd	r25, Y+4	; 0x04
     618:	82 30       	cpi	r24, 0x02	; 2
     61a:	91 05       	cpc	r25, r1
     61c:	51 f1       	breq	.+84     	; 0x672 <M_DIO_void_TogPinValue+0x78>
     61e:	2b 81       	ldd	r18, Y+3	; 0x03
     620:	3c 81       	ldd	r19, Y+4	; 0x04
     622:	23 30       	cpi	r18, 0x03	; 3
     624:	31 05       	cpc	r19, r1
     626:	34 f4       	brge	.+12     	; 0x634 <M_DIO_void_TogPinValue+0x3a>
     628:	8b 81       	ldd	r24, Y+3	; 0x03
     62a:	9c 81       	ldd	r25, Y+4	; 0x04
     62c:	81 30       	cpi	r24, 0x01	; 1
     62e:	91 05       	cpc	r25, r1
     630:	61 f0       	breq	.+24     	; 0x64a <M_DIO_void_TogPinValue+0x50>
     632:	5a c0       	rjmp	.+180    	; 0x6e8 <M_DIO_void_TogPinValue+0xee>
     634:	2b 81       	ldd	r18, Y+3	; 0x03
     636:	3c 81       	ldd	r19, Y+4	; 0x04
     638:	23 30       	cpi	r18, 0x03	; 3
     63a:	31 05       	cpc	r19, r1
     63c:	71 f1       	breq	.+92     	; 0x69a <M_DIO_void_TogPinValue+0xa0>
     63e:	8b 81       	ldd	r24, Y+3	; 0x03
     640:	9c 81       	ldd	r25, Y+4	; 0x04
     642:	84 30       	cpi	r24, 0x04	; 4
     644:	91 05       	cpc	r25, r1
     646:	e9 f1       	breq	.+122    	; 0x6c2 <M_DIO_void_TogPinValue+0xc8>
     648:	4f c0       	rjmp	.+158    	; 0x6e8 <M_DIO_void_TogPinValue+0xee>
		case PORTA_ID:
			TOG_BIT(PORTA_REG,Pin);
     64a:	ab e3       	ldi	r26, 0x3B	; 59
     64c:	b0 e0       	ldi	r27, 0x00	; 0
     64e:	eb e3       	ldi	r30, 0x3B	; 59
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	48 2f       	mov	r20, r24
     656:	8a 81       	ldd	r24, Y+2	; 0x02
     658:	28 2f       	mov	r18, r24
     65a:	30 e0       	ldi	r19, 0x00	; 0
     65c:	81 e0       	ldi	r24, 0x01	; 1
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	02 2e       	mov	r0, r18
     662:	02 c0       	rjmp	.+4      	; 0x668 <M_DIO_void_TogPinValue+0x6e>
     664:	88 0f       	add	r24, r24
     666:	99 1f       	adc	r25, r25
     668:	0a 94       	dec	r0
     66a:	e2 f7       	brpl	.-8      	; 0x664 <M_DIO_void_TogPinValue+0x6a>
     66c:	84 27       	eor	r24, r20
     66e:	8c 93       	st	X, r24
     670:	3b c0       	rjmp	.+118    	; 0x6e8 <M_DIO_void_TogPinValue+0xee>
			break;
		case PORTB_ID:
			TOG_BIT(PORTB_REG,Pin);
     672:	a8 e3       	ldi	r26, 0x38	; 56
     674:	b0 e0       	ldi	r27, 0x00	; 0
     676:	e8 e3       	ldi	r30, 0x38	; 56
     678:	f0 e0       	ldi	r31, 0x00	; 0
     67a:	80 81       	ld	r24, Z
     67c:	48 2f       	mov	r20, r24
     67e:	8a 81       	ldd	r24, Y+2	; 0x02
     680:	28 2f       	mov	r18, r24
     682:	30 e0       	ldi	r19, 0x00	; 0
     684:	81 e0       	ldi	r24, 0x01	; 1
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	02 2e       	mov	r0, r18
     68a:	02 c0       	rjmp	.+4      	; 0x690 <M_DIO_void_TogPinValue+0x96>
     68c:	88 0f       	add	r24, r24
     68e:	99 1f       	adc	r25, r25
     690:	0a 94       	dec	r0
     692:	e2 f7       	brpl	.-8      	; 0x68c <M_DIO_void_TogPinValue+0x92>
     694:	84 27       	eor	r24, r20
     696:	8c 93       	st	X, r24
     698:	27 c0       	rjmp	.+78     	; 0x6e8 <M_DIO_void_TogPinValue+0xee>
			break;
		case PORTC_ID:
			TOG_BIT(PORTC_REG,Pin);
     69a:	a5 e3       	ldi	r26, 0x35	; 53
     69c:	b0 e0       	ldi	r27, 0x00	; 0
     69e:	e5 e3       	ldi	r30, 0x35	; 53
     6a0:	f0 e0       	ldi	r31, 0x00	; 0
     6a2:	80 81       	ld	r24, Z
     6a4:	48 2f       	mov	r20, r24
     6a6:	8a 81       	ldd	r24, Y+2	; 0x02
     6a8:	28 2f       	mov	r18, r24
     6aa:	30 e0       	ldi	r19, 0x00	; 0
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	02 2e       	mov	r0, r18
     6b2:	02 c0       	rjmp	.+4      	; 0x6b8 <M_DIO_void_TogPinValue+0xbe>
     6b4:	88 0f       	add	r24, r24
     6b6:	99 1f       	adc	r25, r25
     6b8:	0a 94       	dec	r0
     6ba:	e2 f7       	brpl	.-8      	; 0x6b4 <M_DIO_void_TogPinValue+0xba>
     6bc:	84 27       	eor	r24, r20
     6be:	8c 93       	st	X, r24
     6c0:	13 c0       	rjmp	.+38     	; 0x6e8 <M_DIO_void_TogPinValue+0xee>
			break;
		case PORTD_ID:
			TOG_BIT(PORTD_REG,Pin);
     6c2:	a2 e3       	ldi	r26, 0x32	; 50
     6c4:	b0 e0       	ldi	r27, 0x00	; 0
     6c6:	e2 e3       	ldi	r30, 0x32	; 50
     6c8:	f0 e0       	ldi	r31, 0x00	; 0
     6ca:	80 81       	ld	r24, Z
     6cc:	48 2f       	mov	r20, r24
     6ce:	8a 81       	ldd	r24, Y+2	; 0x02
     6d0:	28 2f       	mov	r18, r24
     6d2:	30 e0       	ldi	r19, 0x00	; 0
     6d4:	81 e0       	ldi	r24, 0x01	; 1
     6d6:	90 e0       	ldi	r25, 0x00	; 0
     6d8:	02 2e       	mov	r0, r18
     6da:	02 c0       	rjmp	.+4      	; 0x6e0 <M_DIO_void_TogPinValue+0xe6>
     6dc:	88 0f       	add	r24, r24
     6de:	99 1f       	adc	r25, r25
     6e0:	0a 94       	dec	r0
     6e2:	e2 f7       	brpl	.-8      	; 0x6dc <M_DIO_void_TogPinValue+0xe2>
     6e4:	84 27       	eor	r24, r20
     6e6:	8c 93       	st	X, r24
			break;
		}


}
     6e8:	0f 90       	pop	r0
     6ea:	0f 90       	pop	r0
     6ec:	0f 90       	pop	r0
     6ee:	0f 90       	pop	r0
     6f0:	cf 91       	pop	r28
     6f2:	df 91       	pop	r29
     6f4:	08 95       	ret

000006f6 <main>:
 /*Create Task Handles Create */
 xTaskHandle Task1Hand = NULL;


 int main(void)
{
     6f6:	af 92       	push	r10
     6f8:	bf 92       	push	r11
     6fa:	cf 92       	push	r12
     6fc:	df 92       	push	r13
     6fe:	ef 92       	push	r14
     700:	ff 92       	push	r15
     702:	0f 93       	push	r16
     704:	df 93       	push	r29
     706:	cf 93       	push	r28
     708:	cd b7       	in	r28, 0x3d	; 61
     70a:	de b7       	in	r29, 0x3e	; 62
	/*initialize DIO*/
	M_DIO_void_setPinDir(PORTA_ID,PIN0, OUT);
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	60 e0       	ldi	r22, 0x00	; 0
     710:	41 e0       	ldi	r20, 0x01	; 1
     712:	0e 94 49 00 	call	0x92	; 0x92 <M_DIO_void_setPinDir>
	/*Create tasks*/
	xTaskCreate(LedIntro_code,(const signed char *)"Task1",85,NULL,LedOn_PRIORITY,&Task1Hand);
     716:	20 e6       	ldi	r18, 0x60	; 96
     718:	30 e0       	ldi	r19, 0x00	; 0
     71a:	8c ea       	ldi	r24, 0xAC	; 172
     71c:	93 e0       	ldi	r25, 0x03	; 3
     71e:	ee e6       	ldi	r30, 0x6E	; 110
     720:	f0 e0       	ldi	r31, 0x00	; 0
     722:	b9 01       	movw	r22, r18
     724:	45 e5       	ldi	r20, 0x55	; 85
     726:	50 e0       	ldi	r21, 0x00	; 0
     728:	20 e0       	ldi	r18, 0x00	; 0
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	02 e0       	ldi	r16, 0x02	; 2
     72e:	7f 01       	movw	r14, r30
     730:	cc 24       	eor	r12, r12
     732:	dd 24       	eor	r13, r13
     734:	aa 24       	eor	r10, r10
     736:	bb 24       	eor	r11, r11
     738:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xTaskGenericCreate>

	/*start Scheduler */
	vTaskStartScheduler();
     73c:	0e 94 b8 11 	call	0x2370	; 0x2370 <vTaskStartScheduler>

	/*Never Enter Here */
	return 0;
     740:	80 e0       	ldi	r24, 0x00	; 0
     742:	90 e0       	ldi	r25, 0x00	; 0
}
     744:	cf 91       	pop	r28
     746:	df 91       	pop	r29
     748:	0f 91       	pop	r16
     74a:	ff 90       	pop	r15
     74c:	ef 90       	pop	r14
     74e:	df 90       	pop	r13
     750:	cf 90       	pop	r12
     752:	bf 90       	pop	r11
     754:	af 90       	pop	r10
     756:	08 95       	ret

00000758 <LedIntro_code>:

/*Task1 Code */
 void LedIntro_code(void*pvParamter)
{
     758:	df 93       	push	r29
     75a:	cf 93       	push	r28
     75c:	00 d0       	rcall	.+0      	; 0x75e <LedIntro_code+0x6>
     75e:	cd b7       	in	r28, 0x3d	; 61
     760:	de b7       	in	r29, 0x3e	; 62
     762:	9a 83       	std	Y+2, r25	; 0x02
     764:	89 83       	std	Y+1, r24	; 0x01
	for (;;)
	{

		/*Toggle Led */
		M_DIO_void_setPinValue(PORTA_ID,PIN0, HIGH);
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	60 e0       	ldi	r22, 0x00	; 0
     76a:	41 e0       	ldi	r20, 0x01	; 1
     76c:	0e 94 61 01 	call	0x2c2	; 0x2c2 <M_DIO_void_setPinValue>

		/*Send Task in Blocked Queue for 2000 Ticks */
		vTaskDelay(500);
     770:	84 ef       	ldi	r24, 0xF4	; 244
     772:	91 e0       	ldi	r25, 0x01	; 1
     774:	0e 94 83 11 	call	0x2306	; 0x2306 <vTaskDelay>

		/*Toggle Led */
		M_DIO_void_setPinValue(PORTA_ID,PIN0, LOW);
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	40 e0       	ldi	r20, 0x00	; 0
     77e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <M_DIO_void_setPinValue>

		/*Send Task in Blocked Queue for 2000 Ticks */
		vTaskDelay(500);
     782:	84 ef       	ldi	r24, 0xF4	; 244
     784:	91 e0       	ldi	r25, 0x01	; 1
     786:	0e 94 83 11 	call	0x2306	; 0x2306 <vTaskDelay>
     78a:	ed cf       	rjmp	.-38     	; 0x766 <LedIntro_code+0xe>

0000078c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     78c:	df 93       	push	r29
     78e:	cf 93       	push	r28
     790:	cd b7       	in	r28, 0x3d	; 61
     792:	de b7       	in	r29, 0x3e	; 62
     794:	27 97       	sbiw	r28, 0x07	; 7
     796:	0f b6       	in	r0, 0x3f	; 63
     798:	f8 94       	cli
     79a:	de bf       	out	0x3e, r29	; 62
     79c:	0f be       	out	0x3f, r0	; 63
     79e:	cd bf       	out	0x3d, r28	; 61
     7a0:	9d 83       	std	Y+5, r25	; 0x05
     7a2:	8c 83       	std	Y+4, r24	; 0x04
     7a4:	6e 83       	std	Y+6, r22	; 0x06
     7a6:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     7a8:	8a e1       	ldi	r24, 0x1A	; 26
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pvPortMalloc>
     7b0:	9a 83       	std	Y+2, r25	; 0x02
     7b2:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     7b4:	89 81       	ldd	r24, Y+1	; 0x01
     7b6:	9a 81       	ldd	r25, Y+2	; 0x02
     7b8:	00 97       	sbiw	r24, 0x00	; 0
     7ba:	09 f4       	brne	.+2      	; 0x7be <xCoRoutineCreate+0x32>
     7bc:	6f c0       	rjmp	.+222    	; 0x89c <__stack+0x3d>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     7be:	80 91 70 00 	lds	r24, 0x0070
     7c2:	90 91 71 00 	lds	r25, 0x0071
     7c6:	00 97       	sbiw	r24, 0x00	; 0
     7c8:	41 f4       	brne	.+16     	; 0x7da <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     7ca:	89 81       	ldd	r24, Y+1	; 0x01
     7cc:	9a 81       	ldd	r25, Y+2	; 0x02
     7ce:	90 93 71 00 	sts	0x0071, r25
     7d2:	80 93 70 00 	sts	0x0070, r24
			prvInitialiseCoRoutineLists();
     7d6:	0e 94 2d 06 	call	0xc5a	; 0xc5a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     7da:	8e 81       	ldd	r24, Y+6	; 0x06
     7dc:	82 30       	cpi	r24, 0x02	; 2
     7de:	10 f0       	brcs	.+4      	; 0x7e4 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     7e4:	e9 81       	ldd	r30, Y+1	; 0x01
     7e6:	fa 81       	ldd	r31, Y+2	; 0x02
     7e8:	11 8e       	std	Z+25, r1	; 0x19
     7ea:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     7ec:	e9 81       	ldd	r30, Y+1	; 0x01
     7ee:	fa 81       	ldd	r31, Y+2	; 0x02
     7f0:	8e 81       	ldd	r24, Y+6	; 0x06
     7f2:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     7f4:	e9 81       	ldd	r30, Y+1	; 0x01
     7f6:	fa 81       	ldd	r31, Y+2	; 0x02
     7f8:	8f 81       	ldd	r24, Y+7	; 0x07
     7fa:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     7fc:	e9 81       	ldd	r30, Y+1	; 0x01
     7fe:	fa 81       	ldd	r31, Y+2	; 0x02
     800:	8c 81       	ldd	r24, Y+4	; 0x04
     802:	9d 81       	ldd	r25, Y+5	; 0x05
     804:	91 83       	std	Z+1, r25	; 0x01
     806:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     808:	89 81       	ldd	r24, Y+1	; 0x01
     80a:	9a 81       	ldd	r25, Y+2	; 0x02
     80c:	02 96       	adiw	r24, 0x02	; 2
     80e:	0e 94 34 07 	call	0xe68	; 0xe68 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     812:	89 81       	ldd	r24, Y+1	; 0x01
     814:	9a 81       	ldd	r25, Y+2	; 0x02
     816:	0c 96       	adiw	r24, 0x0c	; 12
     818:	0e 94 34 07 	call	0xe68	; 0xe68 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     81c:	e9 81       	ldd	r30, Y+1	; 0x01
     81e:	fa 81       	ldd	r31, Y+2	; 0x02
     820:	89 81       	ldd	r24, Y+1	; 0x01
     822:	9a 81       	ldd	r25, Y+2	; 0x02
     824:	91 87       	std	Z+9, r25	; 0x09
     826:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     828:	e9 81       	ldd	r30, Y+1	; 0x01
     82a:	fa 81       	ldd	r31, Y+2	; 0x02
     82c:	89 81       	ldd	r24, Y+1	; 0x01
     82e:	9a 81       	ldd	r25, Y+2	; 0x02
     830:	93 8b       	std	Z+19, r25	; 0x13
     832:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     834:	8e 81       	ldd	r24, Y+6	; 0x06
     836:	28 2f       	mov	r18, r24
     838:	30 e0       	ldi	r19, 0x00	; 0
     83a:	85 e0       	ldi	r24, 0x05	; 5
     83c:	90 e0       	ldi	r25, 0x00	; 0
     83e:	82 1b       	sub	r24, r18
     840:	93 0b       	sbc	r25, r19
     842:	e9 81       	ldd	r30, Y+1	; 0x01
     844:	fa 81       	ldd	r31, Y+2	; 0x02
     846:	95 87       	std	Z+13, r25	; 0x0d
     848:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     84a:	e9 81       	ldd	r30, Y+1	; 0x01
     84c:	fa 81       	ldd	r31, Y+2	; 0x02
     84e:	96 89       	ldd	r25, Z+22	; 0x16
     850:	80 91 72 00 	lds	r24, 0x0072
     854:	89 17       	cp	r24, r25
     856:	28 f4       	brcc	.+10     	; 0x862 <__stack+0x3>
     858:	e9 81       	ldd	r30, Y+1	; 0x01
     85a:	fa 81       	ldd	r31, Y+2	; 0x02
     85c:	86 89       	ldd	r24, Z+22	; 0x16
     85e:	80 93 72 00 	sts	0x0072, r24
     862:	e9 81       	ldd	r30, Y+1	; 0x01
     864:	fa 81       	ldd	r31, Y+2	; 0x02
     866:	86 89       	ldd	r24, Z+22	; 0x16
     868:	28 2f       	mov	r18, r24
     86a:	30 e0       	ldi	r19, 0x00	; 0
     86c:	c9 01       	movw	r24, r18
     86e:	88 0f       	add	r24, r24
     870:	99 1f       	adc	r25, r25
     872:	88 0f       	add	r24, r24
     874:	99 1f       	adc	r25, r25
     876:	88 0f       	add	r24, r24
     878:	99 1f       	adc	r25, r25
     87a:	82 0f       	add	r24, r18
     87c:	93 1f       	adc	r25, r19
     87e:	ac 01       	movw	r20, r24
     880:	47 58       	subi	r20, 0x87	; 135
     882:	5f 4f       	sbci	r21, 0xFF	; 255
     884:	89 81       	ldd	r24, Y+1	; 0x01
     886:	9a 81       	ldd	r25, Y+2	; 0x02
     888:	9c 01       	movw	r18, r24
     88a:	2e 5f       	subi	r18, 0xFE	; 254
     88c:	3f 4f       	sbci	r19, 0xFF	; 255
     88e:	ca 01       	movw	r24, r20
     890:	b9 01       	movw	r22, r18
     892:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>

		xReturn = pdPASS;
     896:	81 e0       	ldi	r24, 0x01	; 1
     898:	8b 83       	std	Y+3, r24	; 0x03
     89a:	02 c0       	rjmp	.+4      	; 0x8a0 <__stack+0x41>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     89c:	8f ef       	ldi	r24, 0xFF	; 255
     89e:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     8a0:	8b 81       	ldd	r24, Y+3	; 0x03
}
     8a2:	27 96       	adiw	r28, 0x07	; 7
     8a4:	0f b6       	in	r0, 0x3f	; 63
     8a6:	f8 94       	cli
     8a8:	de bf       	out	0x3e, r29	; 62
     8aa:	0f be       	out	0x3f, r0	; 63
     8ac:	cd bf       	out	0x3d, r28	; 61
     8ae:	cf 91       	pop	r28
     8b0:	df 91       	pop	r29
     8b2:	08 95       	ret

000008b4 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     8b4:	df 93       	push	r29
     8b6:	cf 93       	push	r28
     8b8:	00 d0       	rcall	.+0      	; 0x8ba <vCoRoutineAddToDelayedList+0x6>
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <vCoRoutineAddToDelayedList+0x8>
     8bc:	00 d0       	rcall	.+0      	; 0x8be <vCoRoutineAddToDelayedList+0xa>
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	9c 83       	std	Y+4, r25	; 0x04
     8c4:	8b 83       	std	Y+3, r24	; 0x03
     8c6:	7e 83       	std	Y+6, r23	; 0x06
     8c8:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     8ca:	20 91 73 00 	lds	r18, 0x0073
     8ce:	30 91 74 00 	lds	r19, 0x0074
     8d2:	8b 81       	ldd	r24, Y+3	; 0x03
     8d4:	9c 81       	ldd	r25, Y+4	; 0x04
     8d6:	82 0f       	add	r24, r18
     8d8:	93 1f       	adc	r25, r19
     8da:	9a 83       	std	Y+2, r25	; 0x02
     8dc:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     8de:	80 91 70 00 	lds	r24, 0x0070
     8e2:	90 91 71 00 	lds	r25, 0x0071
     8e6:	02 96       	adiw	r24, 0x02	; 2
     8e8:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     8ec:	e0 91 70 00 	lds	r30, 0x0070
     8f0:	f0 91 71 00 	lds	r31, 0x0071
     8f4:	89 81       	ldd	r24, Y+1	; 0x01
     8f6:	9a 81       	ldd	r25, Y+2	; 0x02
     8f8:	93 83       	std	Z+3, r25	; 0x03
     8fa:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     8fc:	20 91 73 00 	lds	r18, 0x0073
     900:	30 91 74 00 	lds	r19, 0x0074
     904:	89 81       	ldd	r24, Y+1	; 0x01
     906:	9a 81       	ldd	r25, Y+2	; 0x02
     908:	82 17       	cp	r24, r18
     90a:	93 07       	cpc	r25, r19
     90c:	70 f4       	brcc	.+28     	; 0x92a <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     90e:	80 91 9f 00 	lds	r24, 0x009F
     912:	90 91 a0 00 	lds	r25, 0x00A0
     916:	20 91 70 00 	lds	r18, 0x0070
     91a:	30 91 71 00 	lds	r19, 0x0071
     91e:	2e 5f       	subi	r18, 0xFE	; 254
     920:	3f 4f       	sbci	r19, 0xFF	; 255
     922:	b9 01       	movw	r22, r18
     924:	0e 94 90 07 	call	0xf20	; 0xf20 <vListInsert>
     928:	0d c0       	rjmp	.+26     	; 0x944 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     92a:	80 91 9d 00 	lds	r24, 0x009D
     92e:	90 91 9e 00 	lds	r25, 0x009E
     932:	20 91 70 00 	lds	r18, 0x0070
     936:	30 91 71 00 	lds	r19, 0x0071
     93a:	2e 5f       	subi	r18, 0xFE	; 254
     93c:	3f 4f       	sbci	r19, 0xFF	; 255
     93e:	b9 01       	movw	r22, r18
     940:	0e 94 90 07 	call	0xf20	; 0xf20 <vListInsert>
	}

	if( pxEventList )
     944:	8d 81       	ldd	r24, Y+5	; 0x05
     946:	9e 81       	ldd	r25, Y+6	; 0x06
     948:	00 97       	sbiw	r24, 0x00	; 0
     94a:	61 f0       	breq	.+24     	; 0x964 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     94c:	80 91 70 00 	lds	r24, 0x0070
     950:	90 91 71 00 	lds	r25, 0x0071
     954:	9c 01       	movw	r18, r24
     956:	24 5f       	subi	r18, 0xF4	; 244
     958:	3f 4f       	sbci	r19, 0xFF	; 255
     95a:	8d 81       	ldd	r24, Y+5	; 0x05
     95c:	9e 81       	ldd	r25, Y+6	; 0x06
     95e:	b9 01       	movw	r22, r18
     960:	0e 94 90 07 	call	0xf20	; 0xf20 <vListInsert>
	}
}
     964:	26 96       	adiw	r28, 0x06	; 6
     966:	0f b6       	in	r0, 0x3f	; 63
     968:	f8 94       	cli
     96a:	de bf       	out	0x3e, r29	; 62
     96c:	0f be       	out	0x3f, r0	; 63
     96e:	cd bf       	out	0x3d, r28	; 61
     970:	cf 91       	pop	r28
     972:	df 91       	pop	r29
     974:	08 95       	ret

00000976 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     976:	df 93       	push	r29
     978:	cf 93       	push	r28
     97a:	00 d0       	rcall	.+0      	; 0x97c <prvCheckPendingReadyList+0x6>
     97c:	cd b7       	in	r28, 0x3d	; 61
     97e:	de b7       	in	r29, 0x3e	; 62
     980:	3a c0       	rjmp	.+116    	; 0x9f6 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     982:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     984:	e0 91 a6 00 	lds	r30, 0x00A6
     988:	f0 91 a7 00 	lds	r31, 0x00A7
     98c:	86 81       	ldd	r24, Z+6	; 0x06
     98e:	97 81       	ldd	r25, Z+7	; 0x07
     990:	9a 83       	std	Y+2, r25	; 0x02
     992:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     994:	89 81       	ldd	r24, Y+1	; 0x01
     996:	9a 81       	ldd	r25, Y+2	; 0x02
     998:	0c 96       	adiw	r24, 0x0c	; 12
     99a:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     99e:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     9a0:	89 81       	ldd	r24, Y+1	; 0x01
     9a2:	9a 81       	ldd	r25, Y+2	; 0x02
     9a4:	02 96       	adiw	r24, 0x02	; 2
     9a6:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     9aa:	e9 81       	ldd	r30, Y+1	; 0x01
     9ac:	fa 81       	ldd	r31, Y+2	; 0x02
     9ae:	96 89       	ldd	r25, Z+22	; 0x16
     9b0:	80 91 72 00 	lds	r24, 0x0072
     9b4:	89 17       	cp	r24, r25
     9b6:	28 f4       	brcc	.+10     	; 0x9c2 <prvCheckPendingReadyList+0x4c>
     9b8:	e9 81       	ldd	r30, Y+1	; 0x01
     9ba:	fa 81       	ldd	r31, Y+2	; 0x02
     9bc:	86 89       	ldd	r24, Z+22	; 0x16
     9be:	80 93 72 00 	sts	0x0072, r24
     9c2:	e9 81       	ldd	r30, Y+1	; 0x01
     9c4:	fa 81       	ldd	r31, Y+2	; 0x02
     9c6:	86 89       	ldd	r24, Z+22	; 0x16
     9c8:	28 2f       	mov	r18, r24
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	c9 01       	movw	r24, r18
     9ce:	88 0f       	add	r24, r24
     9d0:	99 1f       	adc	r25, r25
     9d2:	88 0f       	add	r24, r24
     9d4:	99 1f       	adc	r25, r25
     9d6:	88 0f       	add	r24, r24
     9d8:	99 1f       	adc	r25, r25
     9da:	82 0f       	add	r24, r18
     9dc:	93 1f       	adc	r25, r19
     9de:	ac 01       	movw	r20, r24
     9e0:	47 58       	subi	r20, 0x87	; 135
     9e2:	5f 4f       	sbci	r21, 0xFF	; 255
     9e4:	89 81       	ldd	r24, Y+1	; 0x01
     9e6:	9a 81       	ldd	r25, Y+2	; 0x02
     9e8:	9c 01       	movw	r18, r24
     9ea:	2e 5f       	subi	r18, 0xFE	; 254
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	ca 01       	movw	r24, r20
     9f0:	b9 01       	movw	r22, r18
     9f2:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     9f6:	80 91 a1 00 	lds	r24, 0x00A1
     9fa:	88 23       	and	r24, r24
     9fc:	09 f0       	breq	.+2      	; 0xa00 <prvCheckPendingReadyList+0x8a>
     9fe:	c1 cf       	rjmp	.-126    	; 0x982 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     a00:	0f 90       	pop	r0
     a02:	0f 90       	pop	r0
     a04:	cf 91       	pop	r28
     a06:	df 91       	pop	r29
     a08:	08 95       	ret

00000a0a <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     a0a:	df 93       	push	r29
     a0c:	cf 93       	push	r28
     a0e:	00 d0       	rcall	.+0      	; 0xa10 <prvCheckDelayedList+0x6>
     a10:	00 d0       	rcall	.+0      	; 0xa12 <prvCheckDelayedList+0x8>
     a12:	cd b7       	in	r28, 0x3d	; 61
     a14:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     a16:	0e 94 8f 12 	call	0x251e	; 0x251e <xTaskGetTickCount>
     a1a:	20 91 75 00 	lds	r18, 0x0075
     a1e:	30 91 76 00 	lds	r19, 0x0076
     a22:	82 1b       	sub	r24, r18
     a24:	93 0b       	sbc	r25, r19
     a26:	90 93 78 00 	sts	0x0078, r25
     a2a:	80 93 77 00 	sts	0x0077, r24
     a2e:	85 c0       	rjmp	.+266    	; 0xb3a <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     a30:	80 91 73 00 	lds	r24, 0x0073
     a34:	90 91 74 00 	lds	r25, 0x0074
     a38:	01 96       	adiw	r24, 0x01	; 1
     a3a:	90 93 74 00 	sts	0x0074, r25
     a3e:	80 93 73 00 	sts	0x0073, r24
		xPassedTicks--;
     a42:	80 91 77 00 	lds	r24, 0x0077
     a46:	90 91 78 00 	lds	r25, 0x0078
     a4a:	01 97       	sbiw	r24, 0x01	; 1
     a4c:	90 93 78 00 	sts	0x0078, r25
     a50:	80 93 77 00 	sts	0x0077, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     a54:	80 91 73 00 	lds	r24, 0x0073
     a58:	90 91 74 00 	lds	r25, 0x0074
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	09 f0       	breq	.+2      	; 0xa62 <prvCheckDelayedList+0x58>
     a60:	64 c0       	rjmp	.+200    	; 0xb2a <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     a62:	80 91 9d 00 	lds	r24, 0x009D
     a66:	90 91 9e 00 	lds	r25, 0x009E
     a6a:	9a 83       	std	Y+2, r25	; 0x02
     a6c:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     a6e:	80 91 9f 00 	lds	r24, 0x009F
     a72:	90 91 a0 00 	lds	r25, 0x00A0
     a76:	90 93 9e 00 	sts	0x009E, r25
     a7a:	80 93 9d 00 	sts	0x009D, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     a7e:	89 81       	ldd	r24, Y+1	; 0x01
     a80:	9a 81       	ldd	r25, Y+2	; 0x02
     a82:	90 93 a0 00 	sts	0x00A0, r25
     a86:	80 93 9f 00 	sts	0x009F, r24
     a8a:	4f c0       	rjmp	.+158    	; 0xb2a <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     a8c:	e0 91 9d 00 	lds	r30, 0x009D
     a90:	f0 91 9e 00 	lds	r31, 0x009E
     a94:	05 80       	ldd	r0, Z+5	; 0x05
     a96:	f6 81       	ldd	r31, Z+6	; 0x06
     a98:	e0 2d       	mov	r30, r0
     a9a:	86 81       	ldd	r24, Z+6	; 0x06
     a9c:	97 81       	ldd	r25, Z+7	; 0x07
     a9e:	9c 83       	std	Y+4, r25	; 0x04
     aa0:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     aa2:	eb 81       	ldd	r30, Y+3	; 0x03
     aa4:	fc 81       	ldd	r31, Y+4	; 0x04
     aa6:	22 81       	ldd	r18, Z+2	; 0x02
     aa8:	33 81       	ldd	r19, Z+3	; 0x03
     aaa:	80 91 73 00 	lds	r24, 0x0073
     aae:	90 91 74 00 	lds	r25, 0x0074
     ab2:	82 17       	cp	r24, r18
     ab4:	93 07       	cpc	r25, r19
     ab6:	08 f4       	brcc	.+2      	; 0xaba <prvCheckDelayedList+0xb0>
     ab8:	40 c0       	rjmp	.+128    	; 0xb3a <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     aba:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     abc:	8b 81       	ldd	r24, Y+3	; 0x03
     abe:	9c 81       	ldd	r25, Y+4	; 0x04
     ac0:	02 96       	adiw	r24, 0x02	; 2
     ac2:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     ac6:	eb 81       	ldd	r30, Y+3	; 0x03
     ac8:	fc 81       	ldd	r31, Y+4	; 0x04
     aca:	84 89       	ldd	r24, Z+20	; 0x14
     acc:	95 89       	ldd	r25, Z+21	; 0x15
     ace:	00 97       	sbiw	r24, 0x00	; 0
     ad0:	29 f0       	breq	.+10     	; 0xadc <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     ad2:	8b 81       	ldd	r24, Y+3	; 0x03
     ad4:	9c 81       	ldd	r25, Y+4	; 0x04
     ad6:	0c 96       	adiw	r24, 0x0c	; 12
     ad8:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     adc:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     ade:	eb 81       	ldd	r30, Y+3	; 0x03
     ae0:	fc 81       	ldd	r31, Y+4	; 0x04
     ae2:	96 89       	ldd	r25, Z+22	; 0x16
     ae4:	80 91 72 00 	lds	r24, 0x0072
     ae8:	89 17       	cp	r24, r25
     aea:	28 f4       	brcc	.+10     	; 0xaf6 <prvCheckDelayedList+0xec>
     aec:	eb 81       	ldd	r30, Y+3	; 0x03
     aee:	fc 81       	ldd	r31, Y+4	; 0x04
     af0:	86 89       	ldd	r24, Z+22	; 0x16
     af2:	80 93 72 00 	sts	0x0072, r24
     af6:	eb 81       	ldd	r30, Y+3	; 0x03
     af8:	fc 81       	ldd	r31, Y+4	; 0x04
     afa:	86 89       	ldd	r24, Z+22	; 0x16
     afc:	28 2f       	mov	r18, r24
     afe:	30 e0       	ldi	r19, 0x00	; 0
     b00:	c9 01       	movw	r24, r18
     b02:	88 0f       	add	r24, r24
     b04:	99 1f       	adc	r25, r25
     b06:	88 0f       	add	r24, r24
     b08:	99 1f       	adc	r25, r25
     b0a:	88 0f       	add	r24, r24
     b0c:	99 1f       	adc	r25, r25
     b0e:	82 0f       	add	r24, r18
     b10:	93 1f       	adc	r25, r19
     b12:	ac 01       	movw	r20, r24
     b14:	47 58       	subi	r20, 0x87	; 135
     b16:	5f 4f       	sbci	r21, 0xFF	; 255
     b18:	8b 81       	ldd	r24, Y+3	; 0x03
     b1a:	9c 81       	ldd	r25, Y+4	; 0x04
     b1c:	9c 01       	movw	r18, r24
     b1e:	2e 5f       	subi	r18, 0xFE	; 254
     b20:	3f 4f       	sbci	r19, 0xFF	; 255
     b22:	ca 01       	movw	r24, r20
     b24:	b9 01       	movw	r22, r18
     b26:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     b2a:	e0 91 9d 00 	lds	r30, 0x009D
     b2e:	f0 91 9e 00 	lds	r31, 0x009E
     b32:	80 81       	ld	r24, Z
     b34:	88 23       	and	r24, r24
     b36:	09 f0       	breq	.+2      	; 0xb3a <prvCheckDelayedList+0x130>
     b38:	a9 cf       	rjmp	.-174    	; 0xa8c <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     b3a:	80 91 77 00 	lds	r24, 0x0077
     b3e:	90 91 78 00 	lds	r25, 0x0078
     b42:	00 97       	sbiw	r24, 0x00	; 0
     b44:	09 f0       	breq	.+2      	; 0xb48 <prvCheckDelayedList+0x13e>
     b46:	74 cf       	rjmp	.-280    	; 0xa30 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     b48:	80 91 73 00 	lds	r24, 0x0073
     b4c:	90 91 74 00 	lds	r25, 0x0074
     b50:	90 93 76 00 	sts	0x0076, r25
     b54:	80 93 75 00 	sts	0x0075, r24
}
     b58:	0f 90       	pop	r0
     b5a:	0f 90       	pop	r0
     b5c:	0f 90       	pop	r0
     b5e:	0f 90       	pop	r0
     b60:	cf 91       	pop	r28
     b62:	df 91       	pop	r29
     b64:	08 95       	ret

00000b66 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     b66:	df 93       	push	r29
     b68:	cf 93       	push	r28
     b6a:	00 d0       	rcall	.+0      	; 0xb6c <vCoRoutineSchedule+0x6>
     b6c:	cd b7       	in	r28, 0x3d	; 61
     b6e:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     b70:	0e 94 bb 04 	call	0x976	; 0x976 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     b74:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvCheckDelayedList>
     b78:	0a c0       	rjmp	.+20     	; 0xb8e <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     b7a:	80 91 72 00 	lds	r24, 0x0072
     b7e:	88 23       	and	r24, r24
     b80:	09 f4       	brne	.+2      	; 0xb84 <vCoRoutineSchedule+0x1e>
     b82:	66 c0       	rjmp	.+204    	; 0xc50 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     b84:	80 91 72 00 	lds	r24, 0x0072
     b88:	81 50       	subi	r24, 0x01	; 1
     b8a:	80 93 72 00 	sts	0x0072, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     b8e:	80 91 72 00 	lds	r24, 0x0072
     b92:	28 2f       	mov	r18, r24
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	c9 01       	movw	r24, r18
     b98:	88 0f       	add	r24, r24
     b9a:	99 1f       	adc	r25, r25
     b9c:	88 0f       	add	r24, r24
     b9e:	99 1f       	adc	r25, r25
     ba0:	88 0f       	add	r24, r24
     ba2:	99 1f       	adc	r25, r25
     ba4:	82 0f       	add	r24, r18
     ba6:	93 1f       	adc	r25, r19
     ba8:	fc 01       	movw	r30, r24
     baa:	e7 58       	subi	r30, 0x87	; 135
     bac:	ff 4f       	sbci	r31, 0xFF	; 255
     bae:	80 81       	ld	r24, Z
     bb0:	88 23       	and	r24, r24
     bb2:	19 f3       	breq	.-58     	; 0xb7a <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     bb4:	80 91 72 00 	lds	r24, 0x0072
     bb8:	28 2f       	mov	r18, r24
     bba:	30 e0       	ldi	r19, 0x00	; 0
     bbc:	c9 01       	movw	r24, r18
     bbe:	88 0f       	add	r24, r24
     bc0:	99 1f       	adc	r25, r25
     bc2:	88 0f       	add	r24, r24
     bc4:	99 1f       	adc	r25, r25
     bc6:	88 0f       	add	r24, r24
     bc8:	99 1f       	adc	r25, r25
     bca:	82 0f       	add	r24, r18
     bcc:	93 1f       	adc	r25, r19
     bce:	87 58       	subi	r24, 0x87	; 135
     bd0:	9f 4f       	sbci	r25, 0xFF	; 255
     bd2:	9a 83       	std	Y+2, r25	; 0x02
     bd4:	89 83       	std	Y+1, r24	; 0x01
     bd6:	e9 81       	ldd	r30, Y+1	; 0x01
     bd8:	fa 81       	ldd	r31, Y+2	; 0x02
     bda:	01 80       	ldd	r0, Z+1	; 0x01
     bdc:	f2 81       	ldd	r31, Z+2	; 0x02
     bde:	e0 2d       	mov	r30, r0
     be0:	82 81       	ldd	r24, Z+2	; 0x02
     be2:	93 81       	ldd	r25, Z+3	; 0x03
     be4:	e9 81       	ldd	r30, Y+1	; 0x01
     be6:	fa 81       	ldd	r31, Y+2	; 0x02
     be8:	92 83       	std	Z+2, r25	; 0x02
     bea:	81 83       	std	Z+1, r24	; 0x01
     bec:	e9 81       	ldd	r30, Y+1	; 0x01
     bee:	fa 81       	ldd	r31, Y+2	; 0x02
     bf0:	21 81       	ldd	r18, Z+1	; 0x01
     bf2:	32 81       	ldd	r19, Z+2	; 0x02
     bf4:	89 81       	ldd	r24, Y+1	; 0x01
     bf6:	9a 81       	ldd	r25, Y+2	; 0x02
     bf8:	03 96       	adiw	r24, 0x03	; 3
     bfa:	28 17       	cp	r18, r24
     bfc:	39 07       	cpc	r19, r25
     bfe:	59 f4       	brne	.+22     	; 0xc16 <vCoRoutineSchedule+0xb0>
     c00:	e9 81       	ldd	r30, Y+1	; 0x01
     c02:	fa 81       	ldd	r31, Y+2	; 0x02
     c04:	01 80       	ldd	r0, Z+1	; 0x01
     c06:	f2 81       	ldd	r31, Z+2	; 0x02
     c08:	e0 2d       	mov	r30, r0
     c0a:	82 81       	ldd	r24, Z+2	; 0x02
     c0c:	93 81       	ldd	r25, Z+3	; 0x03
     c0e:	e9 81       	ldd	r30, Y+1	; 0x01
     c10:	fa 81       	ldd	r31, Y+2	; 0x02
     c12:	92 83       	std	Z+2, r25	; 0x02
     c14:	81 83       	std	Z+1, r24	; 0x01
     c16:	e9 81       	ldd	r30, Y+1	; 0x01
     c18:	fa 81       	ldd	r31, Y+2	; 0x02
     c1a:	01 80       	ldd	r0, Z+1	; 0x01
     c1c:	f2 81       	ldd	r31, Z+2	; 0x02
     c1e:	e0 2d       	mov	r30, r0
     c20:	86 81       	ldd	r24, Z+6	; 0x06
     c22:	97 81       	ldd	r25, Z+7	; 0x07
     c24:	90 93 71 00 	sts	0x0071, r25
     c28:	80 93 70 00 	sts	0x0070, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     c2c:	e0 91 70 00 	lds	r30, 0x0070
     c30:	f0 91 71 00 	lds	r31, 0x0071
     c34:	40 81       	ld	r20, Z
     c36:	51 81       	ldd	r21, Z+1	; 0x01
     c38:	80 91 70 00 	lds	r24, 0x0070
     c3c:	90 91 71 00 	lds	r25, 0x0071
     c40:	e0 91 70 00 	lds	r30, 0x0070
     c44:	f0 91 71 00 	lds	r31, 0x0071
     c48:	27 89       	ldd	r18, Z+23	; 0x17
     c4a:	62 2f       	mov	r22, r18
     c4c:	fa 01       	movw	r30, r20
     c4e:	09 95       	icall

	return;
}
     c50:	0f 90       	pop	r0
     c52:	0f 90       	pop	r0
     c54:	cf 91       	pop	r28
     c56:	df 91       	pop	r29
     c58:	08 95       	ret

00000c5a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     c5a:	df 93       	push	r29
     c5c:	cf 93       	push	r28
     c5e:	0f 92       	push	r0
     c60:	cd b7       	in	r28, 0x3d	; 61
     c62:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     c64:	19 82       	std	Y+1, r1	; 0x01
     c66:	13 c0       	rjmp	.+38     	; 0xc8e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     c68:	89 81       	ldd	r24, Y+1	; 0x01
     c6a:	28 2f       	mov	r18, r24
     c6c:	30 e0       	ldi	r19, 0x00	; 0
     c6e:	c9 01       	movw	r24, r18
     c70:	88 0f       	add	r24, r24
     c72:	99 1f       	adc	r25, r25
     c74:	88 0f       	add	r24, r24
     c76:	99 1f       	adc	r25, r25
     c78:	88 0f       	add	r24, r24
     c7a:	99 1f       	adc	r25, r25
     c7c:	82 0f       	add	r24, r18
     c7e:	93 1f       	adc	r25, r19
     c80:	87 58       	subi	r24, 0x87	; 135
     c82:	9f 4f       	sbci	r25, 0xFF	; 255
     c84:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     c88:	89 81       	ldd	r24, Y+1	; 0x01
     c8a:	8f 5f       	subi	r24, 0xFF	; 255
     c8c:	89 83       	std	Y+1, r24	; 0x01
     c8e:	89 81       	ldd	r24, Y+1	; 0x01
     c90:	82 30       	cpi	r24, 0x02	; 2
     c92:	50 f3       	brcs	.-44     	; 0xc68 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     c94:	8b e8       	ldi	r24, 0x8B	; 139
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     c9c:	84 e9       	ldi	r24, 0x94	; 148
     c9e:	90 e0       	ldi	r25, 0x00	; 0
     ca0:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     ca4:	81 ea       	ldi	r24, 0xA1	; 161
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     cac:	8b e8       	ldi	r24, 0x8B	; 139
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	90 93 9e 00 	sts	0x009E, r25
     cb4:	80 93 9d 00 	sts	0x009D, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     cb8:	84 e9       	ldi	r24, 0x94	; 148
     cba:	90 e0       	ldi	r25, 0x00	; 0
     cbc:	90 93 a0 00 	sts	0x00A0, r25
     cc0:	80 93 9f 00 	sts	0x009F, r24
}
     cc4:	0f 90       	pop	r0
     cc6:	cf 91       	pop	r28
     cc8:	df 91       	pop	r29
     cca:	08 95       	ret

00000ccc <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     ccc:	df 93       	push	r29
     cce:	cf 93       	push	r28
     cd0:	00 d0       	rcall	.+0      	; 0xcd2 <xCoRoutineRemoveFromEventList+0x6>
     cd2:	00 d0       	rcall	.+0      	; 0xcd4 <xCoRoutineRemoveFromEventList+0x8>
     cd4:	0f 92       	push	r0
     cd6:	cd b7       	in	r28, 0x3d	; 61
     cd8:	de b7       	in	r29, 0x3e	; 62
     cda:	9d 83       	std	Y+5, r25	; 0x05
     cdc:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     cde:	ec 81       	ldd	r30, Y+4	; 0x04
     ce0:	fd 81       	ldd	r31, Y+5	; 0x05
     ce2:	05 80       	ldd	r0, Z+5	; 0x05
     ce4:	f6 81       	ldd	r31, Z+6	; 0x06
     ce6:	e0 2d       	mov	r30, r0
     ce8:	86 81       	ldd	r24, Z+6	; 0x06
     cea:	97 81       	ldd	r25, Z+7	; 0x07
     cec:	9b 83       	std	Y+3, r25	; 0x03
     cee:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     cf0:	8a 81       	ldd	r24, Y+2	; 0x02
     cf2:	9b 81       	ldd	r25, Y+3	; 0x03
     cf4:	0c 96       	adiw	r24, 0x0c	; 12
     cf6:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     cfa:	8a 81       	ldd	r24, Y+2	; 0x02
     cfc:	9b 81       	ldd	r25, Y+3	; 0x03
     cfe:	9c 01       	movw	r18, r24
     d00:	24 5f       	subi	r18, 0xF4	; 244
     d02:	3f 4f       	sbci	r19, 0xFF	; 255
     d04:	81 ea       	ldi	r24, 0xA1	; 161
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	b9 01       	movw	r22, r18
     d0a:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     d0e:	ea 81       	ldd	r30, Y+2	; 0x02
     d10:	fb 81       	ldd	r31, Y+3	; 0x03
     d12:	96 89       	ldd	r25, Z+22	; 0x16
     d14:	e0 91 70 00 	lds	r30, 0x0070
     d18:	f0 91 71 00 	lds	r31, 0x0071
     d1c:	86 89       	ldd	r24, Z+22	; 0x16
     d1e:	98 17       	cp	r25, r24
     d20:	18 f0       	brcs	.+6      	; 0xd28 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	89 83       	std	Y+1, r24	; 0x01
     d26:	01 c0       	rjmp	.+2      	; 0xd2a <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     d28:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     d2a:	89 81       	ldd	r24, Y+1	; 0x01
}
     d2c:	0f 90       	pop	r0
     d2e:	0f 90       	pop	r0
     d30:	0f 90       	pop	r0
     d32:	0f 90       	pop	r0
     d34:	0f 90       	pop	r0
     d36:	cf 91       	pop	r28
     d38:	df 91       	pop	r29
     d3a:	08 95       	ret

00000d3c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d3c:	df 93       	push	r29
     d3e:	cf 93       	push	r28
     d40:	00 d0       	rcall	.+0      	; 0xd42 <pvPortMalloc+0x6>
     d42:	00 d0       	rcall	.+0      	; 0xd44 <pvPortMalloc+0x8>
     d44:	cd b7       	in	r28, 0x3d	; 61
     d46:	de b7       	in	r29, 0x3e	; 62
     d48:	9c 83       	std	Y+4, r25	; 0x04
     d4a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     d4c:	1a 82       	std	Y+2, r1	; 0x02
     d4e:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     d50:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     d54:	80 91 aa 00 	lds	r24, 0x00AA
     d58:	90 91 ab 00 	lds	r25, 0x00AB
     d5c:	2b 81       	ldd	r18, Y+3	; 0x03
     d5e:	3c 81       	ldd	r19, Y+4	; 0x04
     d60:	82 0f       	add	r24, r18
     d62:	93 1f       	adc	r25, r19
     d64:	22 e0       	ldi	r18, 0x02	; 2
     d66:	88 35       	cpi	r24, 0x58	; 88
     d68:	92 07       	cpc	r25, r18
     d6a:	18 f5       	brcc	.+70     	; 0xdb2 <pvPortMalloc+0x76>
     d6c:	20 91 aa 00 	lds	r18, 0x00AA
     d70:	30 91 ab 00 	lds	r19, 0x00AB
     d74:	8b 81       	ldd	r24, Y+3	; 0x03
     d76:	9c 81       	ldd	r25, Y+4	; 0x04
     d78:	28 0f       	add	r18, r24
     d7a:	39 1f       	adc	r19, r25
     d7c:	80 91 aa 00 	lds	r24, 0x00AA
     d80:	90 91 ab 00 	lds	r25, 0x00AB
     d84:	82 17       	cp	r24, r18
     d86:	93 07       	cpc	r25, r19
     d88:	a0 f4       	brcc	.+40     	; 0xdb2 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     d8a:	80 91 aa 00 	lds	r24, 0x00AA
     d8e:	90 91 ab 00 	lds	r25, 0x00AB
     d92:	84 55       	subi	r24, 0x54	; 84
     d94:	9f 4f       	sbci	r25, 0xFF	; 255
     d96:	9a 83       	std	Y+2, r25	; 0x02
     d98:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     d9a:	20 91 aa 00 	lds	r18, 0x00AA
     d9e:	30 91 ab 00 	lds	r19, 0x00AB
     da2:	8b 81       	ldd	r24, Y+3	; 0x03
     da4:	9c 81       	ldd	r25, Y+4	; 0x04
     da6:	82 0f       	add	r24, r18
     da8:	93 1f       	adc	r25, r19
     daa:	90 93 ab 00 	sts	0x00AB, r25
     dae:	80 93 aa 00 	sts	0x00AA, r24
		}	
	}
	xTaskResumeAll();
     db2:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     db6:	89 81       	ldd	r24, Y+1	; 0x01
     db8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     dba:	0f 90       	pop	r0
     dbc:	0f 90       	pop	r0
     dbe:	0f 90       	pop	r0
     dc0:	0f 90       	pop	r0
     dc2:	cf 91       	pop	r28
     dc4:	df 91       	pop	r29
     dc6:	08 95       	ret

00000dc8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     dc8:	df 93       	push	r29
     dca:	cf 93       	push	r28
     dcc:	00 d0       	rcall	.+0      	; 0xdce <vPortFree+0x6>
     dce:	cd b7       	in	r28, 0x3d	; 61
     dd0:	de b7       	in	r29, 0x3e	; 62
     dd2:	9a 83       	std	Y+2, r25	; 0x02
     dd4:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     dd6:	0f 90       	pop	r0
     dd8:	0f 90       	pop	r0
     dda:	cf 91       	pop	r28
     ddc:	df 91       	pop	r29
     dde:	08 95       	ret

00000de0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     de0:	df 93       	push	r29
     de2:	cf 93       	push	r28
     de4:	cd b7       	in	r28, 0x3d	; 61
     de6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     de8:	10 92 ab 00 	sts	0x00AB, r1
     dec:	10 92 aa 00 	sts	0x00AA, r1
}
     df0:	cf 91       	pop	r28
     df2:	df 91       	pop	r29
     df4:	08 95       	ret

00000df6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     df6:	df 93       	push	r29
     df8:	cf 93       	push	r28
     dfa:	cd b7       	in	r28, 0x3d	; 61
     dfc:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     dfe:	20 91 aa 00 	lds	r18, 0x00AA
     e02:	30 91 ab 00 	lds	r19, 0x00AB
     e06:	88 e5       	ldi	r24, 0x58	; 88
     e08:	92 e0       	ldi	r25, 0x02	; 2
     e0a:	82 1b       	sub	r24, r18
     e0c:	93 0b       	sbc	r25, r19
}
     e0e:	cf 91       	pop	r28
     e10:	df 91       	pop	r29
     e12:	08 95       	ret

00000e14 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     e14:	df 93       	push	r29
     e16:	cf 93       	push	r28
     e18:	00 d0       	rcall	.+0      	; 0xe1a <vListInitialise+0x6>
     e1a:	cd b7       	in	r28, 0x3d	; 61
     e1c:	de b7       	in	r29, 0x3e	; 62
     e1e:	9a 83       	std	Y+2, r25	; 0x02
     e20:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     e22:	89 81       	ldd	r24, Y+1	; 0x01
     e24:	9a 81       	ldd	r25, Y+2	; 0x02
     e26:	03 96       	adiw	r24, 0x03	; 3
     e28:	e9 81       	ldd	r30, Y+1	; 0x01
     e2a:	fa 81       	ldd	r31, Y+2	; 0x02
     e2c:	92 83       	std	Z+2, r25	; 0x02
     e2e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e30:	e9 81       	ldd	r30, Y+1	; 0x01
     e32:	fa 81       	ldd	r31, Y+2	; 0x02
     e34:	8f ef       	ldi	r24, 0xFF	; 255
     e36:	9f ef       	ldi	r25, 0xFF	; 255
     e38:	94 83       	std	Z+4, r25	; 0x04
     e3a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     e3c:	89 81       	ldd	r24, Y+1	; 0x01
     e3e:	9a 81       	ldd	r25, Y+2	; 0x02
     e40:	03 96       	adiw	r24, 0x03	; 3
     e42:	e9 81       	ldd	r30, Y+1	; 0x01
     e44:	fa 81       	ldd	r31, Y+2	; 0x02
     e46:	96 83       	std	Z+6, r25	; 0x06
     e48:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     e4a:	89 81       	ldd	r24, Y+1	; 0x01
     e4c:	9a 81       	ldd	r25, Y+2	; 0x02
     e4e:	03 96       	adiw	r24, 0x03	; 3
     e50:	e9 81       	ldd	r30, Y+1	; 0x01
     e52:	fa 81       	ldd	r31, Y+2	; 0x02
     e54:	90 87       	std	Z+8, r25	; 0x08
     e56:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     e58:	e9 81       	ldd	r30, Y+1	; 0x01
     e5a:	fa 81       	ldd	r31, Y+2	; 0x02
     e5c:	10 82       	st	Z, r1
}
     e5e:	0f 90       	pop	r0
     e60:	0f 90       	pop	r0
     e62:	cf 91       	pop	r28
     e64:	df 91       	pop	r29
     e66:	08 95       	ret

00000e68 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     e68:	df 93       	push	r29
     e6a:	cf 93       	push	r28
     e6c:	00 d0       	rcall	.+0      	; 0xe6e <vListInitialiseItem+0x6>
     e6e:	cd b7       	in	r28, 0x3d	; 61
     e70:	de b7       	in	r29, 0x3e	; 62
     e72:	9a 83       	std	Y+2, r25	; 0x02
     e74:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     e76:	e9 81       	ldd	r30, Y+1	; 0x01
     e78:	fa 81       	ldd	r31, Y+2	; 0x02
     e7a:	11 86       	std	Z+9, r1	; 0x09
     e7c:	10 86       	std	Z+8, r1	; 0x08
}
     e7e:	0f 90       	pop	r0
     e80:	0f 90       	pop	r0
     e82:	cf 91       	pop	r28
     e84:	df 91       	pop	r29
     e86:	08 95       	ret

00000e88 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     e88:	df 93       	push	r29
     e8a:	cf 93       	push	r28
     e8c:	00 d0       	rcall	.+0      	; 0xe8e <vListInsertEnd+0x6>
     e8e:	00 d0       	rcall	.+0      	; 0xe90 <vListInsertEnd+0x8>
     e90:	00 d0       	rcall	.+0      	; 0xe92 <vListInsertEnd+0xa>
     e92:	cd b7       	in	r28, 0x3d	; 61
     e94:	de b7       	in	r29, 0x3e	; 62
     e96:	9c 83       	std	Y+4, r25	; 0x04
     e98:	8b 83       	std	Y+3, r24	; 0x03
     e9a:	7e 83       	std	Y+6, r23	; 0x06
     e9c:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     e9e:	eb 81       	ldd	r30, Y+3	; 0x03
     ea0:	fc 81       	ldd	r31, Y+4	; 0x04
     ea2:	81 81       	ldd	r24, Z+1	; 0x01
     ea4:	92 81       	ldd	r25, Z+2	; 0x02
     ea6:	9a 83       	std	Y+2, r25	; 0x02
     ea8:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     eaa:	e9 81       	ldd	r30, Y+1	; 0x01
     eac:	fa 81       	ldd	r31, Y+2	; 0x02
     eae:	82 81       	ldd	r24, Z+2	; 0x02
     eb0:	93 81       	ldd	r25, Z+3	; 0x03
     eb2:	ed 81       	ldd	r30, Y+5	; 0x05
     eb4:	fe 81       	ldd	r31, Y+6	; 0x06
     eb6:	93 83       	std	Z+3, r25	; 0x03
     eb8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     eba:	eb 81       	ldd	r30, Y+3	; 0x03
     ebc:	fc 81       	ldd	r31, Y+4	; 0x04
     ebe:	81 81       	ldd	r24, Z+1	; 0x01
     ec0:	92 81       	ldd	r25, Z+2	; 0x02
     ec2:	ed 81       	ldd	r30, Y+5	; 0x05
     ec4:	fe 81       	ldd	r31, Y+6	; 0x06
     ec6:	95 83       	std	Z+5, r25	; 0x05
     ec8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     eca:	e9 81       	ldd	r30, Y+1	; 0x01
     ecc:	fa 81       	ldd	r31, Y+2	; 0x02
     ece:	02 80       	ldd	r0, Z+2	; 0x02
     ed0:	f3 81       	ldd	r31, Z+3	; 0x03
     ed2:	e0 2d       	mov	r30, r0
     ed4:	8d 81       	ldd	r24, Y+5	; 0x05
     ed6:	9e 81       	ldd	r25, Y+6	; 0x06
     ed8:	95 83       	std	Z+5, r25	; 0x05
     eda:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     edc:	8d 81       	ldd	r24, Y+5	; 0x05
     ede:	9e 81       	ldd	r25, Y+6	; 0x06
     ee0:	e9 81       	ldd	r30, Y+1	; 0x01
     ee2:	fa 81       	ldd	r31, Y+2	; 0x02
     ee4:	93 83       	std	Z+3, r25	; 0x03
     ee6:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     ee8:	8d 81       	ldd	r24, Y+5	; 0x05
     eea:	9e 81       	ldd	r25, Y+6	; 0x06
     eec:	eb 81       	ldd	r30, Y+3	; 0x03
     eee:	fc 81       	ldd	r31, Y+4	; 0x04
     ef0:	92 83       	std	Z+2, r25	; 0x02
     ef2:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     ef4:	ed 81       	ldd	r30, Y+5	; 0x05
     ef6:	fe 81       	ldd	r31, Y+6	; 0x06
     ef8:	8b 81       	ldd	r24, Y+3	; 0x03
     efa:	9c 81       	ldd	r25, Y+4	; 0x04
     efc:	91 87       	std	Z+9, r25	; 0x09
     efe:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f00:	eb 81       	ldd	r30, Y+3	; 0x03
     f02:	fc 81       	ldd	r31, Y+4	; 0x04
     f04:	80 81       	ld	r24, Z
     f06:	8f 5f       	subi	r24, 0xFF	; 255
     f08:	eb 81       	ldd	r30, Y+3	; 0x03
     f0a:	fc 81       	ldd	r31, Y+4	; 0x04
     f0c:	80 83       	st	Z, r24
}
     f0e:	26 96       	adiw	r28, 0x06	; 6
     f10:	0f b6       	in	r0, 0x3f	; 63
     f12:	f8 94       	cli
     f14:	de bf       	out	0x3e, r29	; 62
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	cd bf       	out	0x3d, r28	; 61
     f1a:	cf 91       	pop	r28
     f1c:	df 91       	pop	r29
     f1e:	08 95       	ret

00000f20 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     f20:	df 93       	push	r29
     f22:	cf 93       	push	r28
     f24:	cd b7       	in	r28, 0x3d	; 61
     f26:	de b7       	in	r29, 0x3e	; 62
     f28:	28 97       	sbiw	r28, 0x08	; 8
     f2a:	0f b6       	in	r0, 0x3f	; 63
     f2c:	f8 94       	cli
     f2e:	de bf       	out	0x3e, r29	; 62
     f30:	0f be       	out	0x3f, r0	; 63
     f32:	cd bf       	out	0x3d, r28	; 61
     f34:	9e 83       	std	Y+6, r25	; 0x06
     f36:	8d 83       	std	Y+5, r24	; 0x05
     f38:	78 87       	std	Y+8, r23	; 0x08
     f3a:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     f3c:	ef 81       	ldd	r30, Y+7	; 0x07
     f3e:	f8 85       	ldd	r31, Y+8	; 0x08
     f40:	80 81       	ld	r24, Z
     f42:	91 81       	ldd	r25, Z+1	; 0x01
     f44:	9a 83       	std	Y+2, r25	; 0x02
     f46:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f48:	89 81       	ldd	r24, Y+1	; 0x01
     f4a:	9a 81       	ldd	r25, Y+2	; 0x02
     f4c:	2f ef       	ldi	r18, 0xFF	; 255
     f4e:	8f 3f       	cpi	r24, 0xFF	; 255
     f50:	92 07       	cpc	r25, r18
     f52:	39 f4       	brne	.+14     	; 0xf62 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     f54:	ed 81       	ldd	r30, Y+5	; 0x05
     f56:	fe 81       	ldd	r31, Y+6	; 0x06
     f58:	87 81       	ldd	r24, Z+7	; 0x07
     f5a:	90 85       	ldd	r25, Z+8	; 0x08
     f5c:	9c 83       	std	Y+4, r25	; 0x04
     f5e:	8b 83       	std	Y+3, r24	; 0x03
     f60:	18 c0       	rjmp	.+48     	; 0xf92 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     f62:	8d 81       	ldd	r24, Y+5	; 0x05
     f64:	9e 81       	ldd	r25, Y+6	; 0x06
     f66:	03 96       	adiw	r24, 0x03	; 3
     f68:	9c 83       	std	Y+4, r25	; 0x04
     f6a:	8b 83       	std	Y+3, r24	; 0x03
     f6c:	06 c0       	rjmp	.+12     	; 0xf7a <vListInsert+0x5a>
     f6e:	eb 81       	ldd	r30, Y+3	; 0x03
     f70:	fc 81       	ldd	r31, Y+4	; 0x04
     f72:	82 81       	ldd	r24, Z+2	; 0x02
     f74:	93 81       	ldd	r25, Z+3	; 0x03
     f76:	9c 83       	std	Y+4, r25	; 0x04
     f78:	8b 83       	std	Y+3, r24	; 0x03
     f7a:	eb 81       	ldd	r30, Y+3	; 0x03
     f7c:	fc 81       	ldd	r31, Y+4	; 0x04
     f7e:	02 80       	ldd	r0, Z+2	; 0x02
     f80:	f3 81       	ldd	r31, Z+3	; 0x03
     f82:	e0 2d       	mov	r30, r0
     f84:	20 81       	ld	r18, Z
     f86:	31 81       	ldd	r19, Z+1	; 0x01
     f88:	89 81       	ldd	r24, Y+1	; 0x01
     f8a:	9a 81       	ldd	r25, Y+2	; 0x02
     f8c:	82 17       	cp	r24, r18
     f8e:	93 07       	cpc	r25, r19
     f90:	70 f7       	brcc	.-36     	; 0xf6e <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     f92:	eb 81       	ldd	r30, Y+3	; 0x03
     f94:	fc 81       	ldd	r31, Y+4	; 0x04
     f96:	82 81       	ldd	r24, Z+2	; 0x02
     f98:	93 81       	ldd	r25, Z+3	; 0x03
     f9a:	ef 81       	ldd	r30, Y+7	; 0x07
     f9c:	f8 85       	ldd	r31, Y+8	; 0x08
     f9e:	93 83       	std	Z+3, r25	; 0x03
     fa0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     fa2:	ef 81       	ldd	r30, Y+7	; 0x07
     fa4:	f8 85       	ldd	r31, Y+8	; 0x08
     fa6:	02 80       	ldd	r0, Z+2	; 0x02
     fa8:	f3 81       	ldd	r31, Z+3	; 0x03
     faa:	e0 2d       	mov	r30, r0
     fac:	8f 81       	ldd	r24, Y+7	; 0x07
     fae:	98 85       	ldd	r25, Y+8	; 0x08
     fb0:	95 83       	std	Z+5, r25	; 0x05
     fb2:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     fb4:	ef 81       	ldd	r30, Y+7	; 0x07
     fb6:	f8 85       	ldd	r31, Y+8	; 0x08
     fb8:	8b 81       	ldd	r24, Y+3	; 0x03
     fba:	9c 81       	ldd	r25, Y+4	; 0x04
     fbc:	95 83       	std	Z+5, r25	; 0x05
     fbe:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     fc0:	8f 81       	ldd	r24, Y+7	; 0x07
     fc2:	98 85       	ldd	r25, Y+8	; 0x08
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	93 83       	std	Z+3, r25	; 0x03
     fca:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     fcc:	ef 81       	ldd	r30, Y+7	; 0x07
     fce:	f8 85       	ldd	r31, Y+8	; 0x08
     fd0:	8d 81       	ldd	r24, Y+5	; 0x05
     fd2:	9e 81       	ldd	r25, Y+6	; 0x06
     fd4:	91 87       	std	Z+9, r25	; 0x09
     fd6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     fd8:	ed 81       	ldd	r30, Y+5	; 0x05
     fda:	fe 81       	ldd	r31, Y+6	; 0x06
     fdc:	80 81       	ld	r24, Z
     fde:	8f 5f       	subi	r24, 0xFF	; 255
     fe0:	ed 81       	ldd	r30, Y+5	; 0x05
     fe2:	fe 81       	ldd	r31, Y+6	; 0x06
     fe4:	80 83       	st	Z, r24
}
     fe6:	28 96       	adiw	r28, 0x08	; 8
     fe8:	0f b6       	in	r0, 0x3f	; 63
     fea:	f8 94       	cli
     fec:	de bf       	out	0x3e, r29	; 62
     fee:	0f be       	out	0x3f, r0	; 63
     ff0:	cd bf       	out	0x3d, r28	; 61
     ff2:	cf 91       	pop	r28
     ff4:	df 91       	pop	r29
     ff6:	08 95       	ret

00000ff8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     ff8:	df 93       	push	r29
     ffa:	cf 93       	push	r28
     ffc:	00 d0       	rcall	.+0      	; 0xffe <vListRemove+0x6>
     ffe:	00 d0       	rcall	.+0      	; 0x1000 <vListRemove+0x8>
    1000:	cd b7       	in	r28, 0x3d	; 61
    1002:	de b7       	in	r29, 0x3e	; 62
    1004:	9c 83       	std	Y+4, r25	; 0x04
    1006:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1008:	eb 81       	ldd	r30, Y+3	; 0x03
    100a:	fc 81       	ldd	r31, Y+4	; 0x04
    100c:	a2 81       	ldd	r26, Z+2	; 0x02
    100e:	b3 81       	ldd	r27, Z+3	; 0x03
    1010:	eb 81       	ldd	r30, Y+3	; 0x03
    1012:	fc 81       	ldd	r31, Y+4	; 0x04
    1014:	84 81       	ldd	r24, Z+4	; 0x04
    1016:	95 81       	ldd	r25, Z+5	; 0x05
    1018:	15 96       	adiw	r26, 0x05	; 5
    101a:	9c 93       	st	X, r25
    101c:	8e 93       	st	-X, r24
    101e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1020:	eb 81       	ldd	r30, Y+3	; 0x03
    1022:	fc 81       	ldd	r31, Y+4	; 0x04
    1024:	a4 81       	ldd	r26, Z+4	; 0x04
    1026:	b5 81       	ldd	r27, Z+5	; 0x05
    1028:	eb 81       	ldd	r30, Y+3	; 0x03
    102a:	fc 81       	ldd	r31, Y+4	; 0x04
    102c:	82 81       	ldd	r24, Z+2	; 0x02
    102e:	93 81       	ldd	r25, Z+3	; 0x03
    1030:	13 96       	adiw	r26, 0x03	; 3
    1032:	9c 93       	st	X, r25
    1034:	8e 93       	st	-X, r24
    1036:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1038:	eb 81       	ldd	r30, Y+3	; 0x03
    103a:	fc 81       	ldd	r31, Y+4	; 0x04
    103c:	80 85       	ldd	r24, Z+8	; 0x08
    103e:	91 85       	ldd	r25, Z+9	; 0x09
    1040:	9a 83       	std	Y+2, r25	; 0x02
    1042:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1044:	e9 81       	ldd	r30, Y+1	; 0x01
    1046:	fa 81       	ldd	r31, Y+2	; 0x02
    1048:	21 81       	ldd	r18, Z+1	; 0x01
    104a:	32 81       	ldd	r19, Z+2	; 0x02
    104c:	8b 81       	ldd	r24, Y+3	; 0x03
    104e:	9c 81       	ldd	r25, Y+4	; 0x04
    1050:	28 17       	cp	r18, r24
    1052:	39 07       	cpc	r19, r25
    1054:	41 f4       	brne	.+16     	; 0x1066 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1056:	eb 81       	ldd	r30, Y+3	; 0x03
    1058:	fc 81       	ldd	r31, Y+4	; 0x04
    105a:	84 81       	ldd	r24, Z+4	; 0x04
    105c:	95 81       	ldd	r25, Z+5	; 0x05
    105e:	e9 81       	ldd	r30, Y+1	; 0x01
    1060:	fa 81       	ldd	r31, Y+2	; 0x02
    1062:	92 83       	std	Z+2, r25	; 0x02
    1064:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	11 86       	std	Z+9, r1	; 0x09
    106c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    106e:	e9 81       	ldd	r30, Y+1	; 0x01
    1070:	fa 81       	ldd	r31, Y+2	; 0x02
    1072:	80 81       	ld	r24, Z
    1074:	81 50       	subi	r24, 0x01	; 1
    1076:	e9 81       	ldd	r30, Y+1	; 0x01
    1078:	fa 81       	ldd	r31, Y+2	; 0x02
    107a:	80 83       	st	Z, r24
}
    107c:	0f 90       	pop	r0
    107e:	0f 90       	pop	r0
    1080:	0f 90       	pop	r0
    1082:	0f 90       	pop	r0
    1084:	cf 91       	pop	r28
    1086:	df 91       	pop	r29
    1088:	08 95       	ret

0000108a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    108a:	df 93       	push	r29
    108c:	cf 93       	push	r28
    108e:	cd b7       	in	r28, 0x3d	; 61
    1090:	de b7       	in	r29, 0x3e	; 62
    1092:	28 97       	sbiw	r28, 0x08	; 8
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	de bf       	out	0x3e, r29	; 62
    109a:	0f be       	out	0x3f, r0	; 63
    109c:	cd bf       	out	0x3d, r28	; 61
    109e:	9c 83       	std	Y+4, r25	; 0x04
    10a0:	8b 83       	std	Y+3, r24	; 0x03
    10a2:	7e 83       	std	Y+6, r23	; 0x06
    10a4:	6d 83       	std	Y+5, r22	; 0x05
    10a6:	58 87       	std	Y+8, r21	; 0x08
    10a8:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    10aa:	eb 81       	ldd	r30, Y+3	; 0x03
    10ac:	fc 81       	ldd	r31, Y+4	; 0x04
    10ae:	81 e1       	ldi	r24, 0x11	; 17
    10b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    10b2:	8b 81       	ldd	r24, Y+3	; 0x03
    10b4:	9c 81       	ldd	r25, Y+4	; 0x04
    10b6:	01 97       	sbiw	r24, 0x01	; 1
    10b8:	9c 83       	std	Y+4, r25	; 0x04
    10ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    10bc:	eb 81       	ldd	r30, Y+3	; 0x03
    10be:	fc 81       	ldd	r31, Y+4	; 0x04
    10c0:	82 e2       	ldi	r24, 0x22	; 34
    10c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    10c4:	8b 81       	ldd	r24, Y+3	; 0x03
    10c6:	9c 81       	ldd	r25, Y+4	; 0x04
    10c8:	01 97       	sbiw	r24, 0x01	; 1
    10ca:	9c 83       	std	Y+4, r25	; 0x04
    10cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    10ce:	eb 81       	ldd	r30, Y+3	; 0x03
    10d0:	fc 81       	ldd	r31, Y+4	; 0x04
    10d2:	83 e3       	ldi	r24, 0x33	; 51
    10d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    10d6:	8b 81       	ldd	r24, Y+3	; 0x03
    10d8:	9c 81       	ldd	r25, Y+4	; 0x04
    10da:	01 97       	sbiw	r24, 0x01	; 1
    10dc:	9c 83       	std	Y+4, r25	; 0x04
    10de:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    10e0:	8d 81       	ldd	r24, Y+5	; 0x05
    10e2:	9e 81       	ldd	r25, Y+6	; 0x06
    10e4:	9a 83       	std	Y+2, r25	; 0x02
    10e6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    10e8:	89 81       	ldd	r24, Y+1	; 0x01
    10ea:	eb 81       	ldd	r30, Y+3	; 0x03
    10ec:	fc 81       	ldd	r31, Y+4	; 0x04
    10ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    10f0:	8b 81       	ldd	r24, Y+3	; 0x03
    10f2:	9c 81       	ldd	r25, Y+4	; 0x04
    10f4:	01 97       	sbiw	r24, 0x01	; 1
    10f6:	9c 83       	std	Y+4, r25	; 0x04
    10f8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    10fa:	89 81       	ldd	r24, Y+1	; 0x01
    10fc:	9a 81       	ldd	r25, Y+2	; 0x02
    10fe:	89 2f       	mov	r24, r25
    1100:	99 27       	eor	r25, r25
    1102:	9a 83       	std	Y+2, r25	; 0x02
    1104:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	eb 81       	ldd	r30, Y+3	; 0x03
    110a:	fc 81       	ldd	r31, Y+4	; 0x04
    110c:	80 83       	st	Z, r24
	pxTopOfStack--;
    110e:	8b 81       	ldd	r24, Y+3	; 0x03
    1110:	9c 81       	ldd	r25, Y+4	; 0x04
    1112:	01 97       	sbiw	r24, 0x01	; 1
    1114:	9c 83       	std	Y+4, r25	; 0x04
    1116:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1118:	eb 81       	ldd	r30, Y+3	; 0x03
    111a:	fc 81       	ldd	r31, Y+4	; 0x04
    111c:	10 82       	st	Z, r1
	pxTopOfStack--;
    111e:	8b 81       	ldd	r24, Y+3	; 0x03
    1120:	9c 81       	ldd	r25, Y+4	; 0x04
    1122:	01 97       	sbiw	r24, 0x01	; 1
    1124:	9c 83       	std	Y+4, r25	; 0x04
    1126:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1128:	eb 81       	ldd	r30, Y+3	; 0x03
    112a:	fc 81       	ldd	r31, Y+4	; 0x04
    112c:	80 e8       	ldi	r24, 0x80	; 128
    112e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1130:	8b 81       	ldd	r24, Y+3	; 0x03
    1132:	9c 81       	ldd	r25, Y+4	; 0x04
    1134:	01 97       	sbiw	r24, 0x01	; 1
    1136:	9c 83       	std	Y+4, r25	; 0x04
    1138:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    113a:	eb 81       	ldd	r30, Y+3	; 0x03
    113c:	fc 81       	ldd	r31, Y+4	; 0x04
    113e:	10 82       	st	Z, r1
	pxTopOfStack--;
    1140:	8b 81       	ldd	r24, Y+3	; 0x03
    1142:	9c 81       	ldd	r25, Y+4	; 0x04
    1144:	01 97       	sbiw	r24, 0x01	; 1
    1146:	9c 83       	std	Y+4, r25	; 0x04
    1148:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    114a:	eb 81       	ldd	r30, Y+3	; 0x03
    114c:	fc 81       	ldd	r31, Y+4	; 0x04
    114e:	82 e0       	ldi	r24, 0x02	; 2
    1150:	80 83       	st	Z, r24
	pxTopOfStack--;
    1152:	8b 81       	ldd	r24, Y+3	; 0x03
    1154:	9c 81       	ldd	r25, Y+4	; 0x04
    1156:	01 97       	sbiw	r24, 0x01	; 1
    1158:	9c 83       	std	Y+4, r25	; 0x04
    115a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    115c:	eb 81       	ldd	r30, Y+3	; 0x03
    115e:	fc 81       	ldd	r31, Y+4	; 0x04
    1160:	83 e0       	ldi	r24, 0x03	; 3
    1162:	80 83       	st	Z, r24
	pxTopOfStack--;
    1164:	8b 81       	ldd	r24, Y+3	; 0x03
    1166:	9c 81       	ldd	r25, Y+4	; 0x04
    1168:	01 97       	sbiw	r24, 0x01	; 1
    116a:	9c 83       	std	Y+4, r25	; 0x04
    116c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    116e:	eb 81       	ldd	r30, Y+3	; 0x03
    1170:	fc 81       	ldd	r31, Y+4	; 0x04
    1172:	84 e0       	ldi	r24, 0x04	; 4
    1174:	80 83       	st	Z, r24
	pxTopOfStack--;
    1176:	8b 81       	ldd	r24, Y+3	; 0x03
    1178:	9c 81       	ldd	r25, Y+4	; 0x04
    117a:	01 97       	sbiw	r24, 0x01	; 1
    117c:	9c 83       	std	Y+4, r25	; 0x04
    117e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1180:	eb 81       	ldd	r30, Y+3	; 0x03
    1182:	fc 81       	ldd	r31, Y+4	; 0x04
    1184:	85 e0       	ldi	r24, 0x05	; 5
    1186:	80 83       	st	Z, r24
	pxTopOfStack--;
    1188:	8b 81       	ldd	r24, Y+3	; 0x03
    118a:	9c 81       	ldd	r25, Y+4	; 0x04
    118c:	01 97       	sbiw	r24, 0x01	; 1
    118e:	9c 83       	std	Y+4, r25	; 0x04
    1190:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1192:	eb 81       	ldd	r30, Y+3	; 0x03
    1194:	fc 81       	ldd	r31, Y+4	; 0x04
    1196:	86 e0       	ldi	r24, 0x06	; 6
    1198:	80 83       	st	Z, r24
	pxTopOfStack--;
    119a:	8b 81       	ldd	r24, Y+3	; 0x03
    119c:	9c 81       	ldd	r25, Y+4	; 0x04
    119e:	01 97       	sbiw	r24, 0x01	; 1
    11a0:	9c 83       	std	Y+4, r25	; 0x04
    11a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    11a4:	eb 81       	ldd	r30, Y+3	; 0x03
    11a6:	fc 81       	ldd	r31, Y+4	; 0x04
    11a8:	87 e0       	ldi	r24, 0x07	; 7
    11aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    11ac:	8b 81       	ldd	r24, Y+3	; 0x03
    11ae:	9c 81       	ldd	r25, Y+4	; 0x04
    11b0:	01 97       	sbiw	r24, 0x01	; 1
    11b2:	9c 83       	std	Y+4, r25	; 0x04
    11b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    11b6:	eb 81       	ldd	r30, Y+3	; 0x03
    11b8:	fc 81       	ldd	r31, Y+4	; 0x04
    11ba:	88 e0       	ldi	r24, 0x08	; 8
    11bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    11be:	8b 81       	ldd	r24, Y+3	; 0x03
    11c0:	9c 81       	ldd	r25, Y+4	; 0x04
    11c2:	01 97       	sbiw	r24, 0x01	; 1
    11c4:	9c 83       	std	Y+4, r25	; 0x04
    11c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    11c8:	eb 81       	ldd	r30, Y+3	; 0x03
    11ca:	fc 81       	ldd	r31, Y+4	; 0x04
    11cc:	89 e0       	ldi	r24, 0x09	; 9
    11ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    11d0:	8b 81       	ldd	r24, Y+3	; 0x03
    11d2:	9c 81       	ldd	r25, Y+4	; 0x04
    11d4:	01 97       	sbiw	r24, 0x01	; 1
    11d6:	9c 83       	std	Y+4, r25	; 0x04
    11d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    11da:	eb 81       	ldd	r30, Y+3	; 0x03
    11dc:	fc 81       	ldd	r31, Y+4	; 0x04
    11de:	80 e1       	ldi	r24, 0x10	; 16
    11e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11e2:	8b 81       	ldd	r24, Y+3	; 0x03
    11e4:	9c 81       	ldd	r25, Y+4	; 0x04
    11e6:	01 97       	sbiw	r24, 0x01	; 1
    11e8:	9c 83       	std	Y+4, r25	; 0x04
    11ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    11ec:	eb 81       	ldd	r30, Y+3	; 0x03
    11ee:	fc 81       	ldd	r31, Y+4	; 0x04
    11f0:	81 e1       	ldi	r24, 0x11	; 17
    11f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    11f4:	8b 81       	ldd	r24, Y+3	; 0x03
    11f6:	9c 81       	ldd	r25, Y+4	; 0x04
    11f8:	01 97       	sbiw	r24, 0x01	; 1
    11fa:	9c 83       	std	Y+4, r25	; 0x04
    11fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    11fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1200:	fc 81       	ldd	r31, Y+4	; 0x04
    1202:	82 e1       	ldi	r24, 0x12	; 18
    1204:	80 83       	st	Z, r24
	pxTopOfStack--;
    1206:	8b 81       	ldd	r24, Y+3	; 0x03
    1208:	9c 81       	ldd	r25, Y+4	; 0x04
    120a:	01 97       	sbiw	r24, 0x01	; 1
    120c:	9c 83       	std	Y+4, r25	; 0x04
    120e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1210:	eb 81       	ldd	r30, Y+3	; 0x03
    1212:	fc 81       	ldd	r31, Y+4	; 0x04
    1214:	83 e1       	ldi	r24, 0x13	; 19
    1216:	80 83       	st	Z, r24
	pxTopOfStack--;
    1218:	8b 81       	ldd	r24, Y+3	; 0x03
    121a:	9c 81       	ldd	r25, Y+4	; 0x04
    121c:	01 97       	sbiw	r24, 0x01	; 1
    121e:	9c 83       	std	Y+4, r25	; 0x04
    1220:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1222:	eb 81       	ldd	r30, Y+3	; 0x03
    1224:	fc 81       	ldd	r31, Y+4	; 0x04
    1226:	84 e1       	ldi	r24, 0x14	; 20
    1228:	80 83       	st	Z, r24
	pxTopOfStack--;
    122a:	8b 81       	ldd	r24, Y+3	; 0x03
    122c:	9c 81       	ldd	r25, Y+4	; 0x04
    122e:	01 97       	sbiw	r24, 0x01	; 1
    1230:	9c 83       	std	Y+4, r25	; 0x04
    1232:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1234:	eb 81       	ldd	r30, Y+3	; 0x03
    1236:	fc 81       	ldd	r31, Y+4	; 0x04
    1238:	85 e1       	ldi	r24, 0x15	; 21
    123a:	80 83       	st	Z, r24
	pxTopOfStack--;
    123c:	8b 81       	ldd	r24, Y+3	; 0x03
    123e:	9c 81       	ldd	r25, Y+4	; 0x04
    1240:	01 97       	sbiw	r24, 0x01	; 1
    1242:	9c 83       	std	Y+4, r25	; 0x04
    1244:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1246:	eb 81       	ldd	r30, Y+3	; 0x03
    1248:	fc 81       	ldd	r31, Y+4	; 0x04
    124a:	86 e1       	ldi	r24, 0x16	; 22
    124c:	80 83       	st	Z, r24
	pxTopOfStack--;
    124e:	8b 81       	ldd	r24, Y+3	; 0x03
    1250:	9c 81       	ldd	r25, Y+4	; 0x04
    1252:	01 97       	sbiw	r24, 0x01	; 1
    1254:	9c 83       	std	Y+4, r25	; 0x04
    1256:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1258:	eb 81       	ldd	r30, Y+3	; 0x03
    125a:	fc 81       	ldd	r31, Y+4	; 0x04
    125c:	87 e1       	ldi	r24, 0x17	; 23
    125e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1260:	8b 81       	ldd	r24, Y+3	; 0x03
    1262:	9c 81       	ldd	r25, Y+4	; 0x04
    1264:	01 97       	sbiw	r24, 0x01	; 1
    1266:	9c 83       	std	Y+4, r25	; 0x04
    1268:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    126a:	eb 81       	ldd	r30, Y+3	; 0x03
    126c:	fc 81       	ldd	r31, Y+4	; 0x04
    126e:	88 e1       	ldi	r24, 0x18	; 24
    1270:	80 83       	st	Z, r24
	pxTopOfStack--;
    1272:	8b 81       	ldd	r24, Y+3	; 0x03
    1274:	9c 81       	ldd	r25, Y+4	; 0x04
    1276:	01 97       	sbiw	r24, 0x01	; 1
    1278:	9c 83       	std	Y+4, r25	; 0x04
    127a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    127c:	eb 81       	ldd	r30, Y+3	; 0x03
    127e:	fc 81       	ldd	r31, Y+4	; 0x04
    1280:	89 e1       	ldi	r24, 0x19	; 25
    1282:	80 83       	st	Z, r24
	pxTopOfStack--;
    1284:	8b 81       	ldd	r24, Y+3	; 0x03
    1286:	9c 81       	ldd	r25, Y+4	; 0x04
    1288:	01 97       	sbiw	r24, 0x01	; 1
    128a:	9c 83       	std	Y+4, r25	; 0x04
    128c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    128e:	eb 81       	ldd	r30, Y+3	; 0x03
    1290:	fc 81       	ldd	r31, Y+4	; 0x04
    1292:	80 e2       	ldi	r24, 0x20	; 32
    1294:	80 83       	st	Z, r24
	pxTopOfStack--;
    1296:	8b 81       	ldd	r24, Y+3	; 0x03
    1298:	9c 81       	ldd	r25, Y+4	; 0x04
    129a:	01 97       	sbiw	r24, 0x01	; 1
    129c:	9c 83       	std	Y+4, r25	; 0x04
    129e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    12a0:	eb 81       	ldd	r30, Y+3	; 0x03
    12a2:	fc 81       	ldd	r31, Y+4	; 0x04
    12a4:	81 e2       	ldi	r24, 0x21	; 33
    12a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    12a8:	8b 81       	ldd	r24, Y+3	; 0x03
    12aa:	9c 81       	ldd	r25, Y+4	; 0x04
    12ac:	01 97       	sbiw	r24, 0x01	; 1
    12ae:	9c 83       	std	Y+4, r25	; 0x04
    12b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    12b2:	eb 81       	ldd	r30, Y+3	; 0x03
    12b4:	fc 81       	ldd	r31, Y+4	; 0x04
    12b6:	82 e2       	ldi	r24, 0x22	; 34
    12b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    12ba:	8b 81       	ldd	r24, Y+3	; 0x03
    12bc:	9c 81       	ldd	r25, Y+4	; 0x04
    12be:	01 97       	sbiw	r24, 0x01	; 1
    12c0:	9c 83       	std	Y+4, r25	; 0x04
    12c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    12c4:	eb 81       	ldd	r30, Y+3	; 0x03
    12c6:	fc 81       	ldd	r31, Y+4	; 0x04
    12c8:	83 e2       	ldi	r24, 0x23	; 35
    12ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    12cc:	8b 81       	ldd	r24, Y+3	; 0x03
    12ce:	9c 81       	ldd	r25, Y+4	; 0x04
    12d0:	01 97       	sbiw	r24, 0x01	; 1
    12d2:	9c 83       	std	Y+4, r25	; 0x04
    12d4:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    12d6:	8f 81       	ldd	r24, Y+7	; 0x07
    12d8:	98 85       	ldd	r25, Y+8	; 0x08
    12da:	9a 83       	std	Y+2, r25	; 0x02
    12dc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    12de:	89 81       	ldd	r24, Y+1	; 0x01
    12e0:	eb 81       	ldd	r30, Y+3	; 0x03
    12e2:	fc 81       	ldd	r31, Y+4	; 0x04
    12e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    12e6:	8b 81       	ldd	r24, Y+3	; 0x03
    12e8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ea:	01 97       	sbiw	r24, 0x01	; 1
    12ec:	9c 83       	std	Y+4, r25	; 0x04
    12ee:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    12f0:	89 81       	ldd	r24, Y+1	; 0x01
    12f2:	9a 81       	ldd	r25, Y+2	; 0x02
    12f4:	89 2f       	mov	r24, r25
    12f6:	99 27       	eor	r25, r25
    12f8:	9a 83       	std	Y+2, r25	; 0x02
    12fa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    12fc:	89 81       	ldd	r24, Y+1	; 0x01
    12fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1300:	fc 81       	ldd	r31, Y+4	; 0x04
    1302:	80 83       	st	Z, r24
	pxTopOfStack--;
    1304:	8b 81       	ldd	r24, Y+3	; 0x03
    1306:	9c 81       	ldd	r25, Y+4	; 0x04
    1308:	01 97       	sbiw	r24, 0x01	; 1
    130a:	9c 83       	std	Y+4, r25	; 0x04
    130c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    130e:	eb 81       	ldd	r30, Y+3	; 0x03
    1310:	fc 81       	ldd	r31, Y+4	; 0x04
    1312:	86 e2       	ldi	r24, 0x26	; 38
    1314:	80 83       	st	Z, r24
	pxTopOfStack--;
    1316:	8b 81       	ldd	r24, Y+3	; 0x03
    1318:	9c 81       	ldd	r25, Y+4	; 0x04
    131a:	01 97       	sbiw	r24, 0x01	; 1
    131c:	9c 83       	std	Y+4, r25	; 0x04
    131e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1320:	eb 81       	ldd	r30, Y+3	; 0x03
    1322:	fc 81       	ldd	r31, Y+4	; 0x04
    1324:	87 e2       	ldi	r24, 0x27	; 39
    1326:	80 83       	st	Z, r24
	pxTopOfStack--;
    1328:	8b 81       	ldd	r24, Y+3	; 0x03
    132a:	9c 81       	ldd	r25, Y+4	; 0x04
    132c:	01 97       	sbiw	r24, 0x01	; 1
    132e:	9c 83       	std	Y+4, r25	; 0x04
    1330:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1332:	eb 81       	ldd	r30, Y+3	; 0x03
    1334:	fc 81       	ldd	r31, Y+4	; 0x04
    1336:	88 e2       	ldi	r24, 0x28	; 40
    1338:	80 83       	st	Z, r24
	pxTopOfStack--;
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	9c 81       	ldd	r25, Y+4	; 0x04
    133e:	01 97       	sbiw	r24, 0x01	; 1
    1340:	9c 83       	std	Y+4, r25	; 0x04
    1342:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1344:	eb 81       	ldd	r30, Y+3	; 0x03
    1346:	fc 81       	ldd	r31, Y+4	; 0x04
    1348:	89 e2       	ldi	r24, 0x29	; 41
    134a:	80 83       	st	Z, r24
	pxTopOfStack--;
    134c:	8b 81       	ldd	r24, Y+3	; 0x03
    134e:	9c 81       	ldd	r25, Y+4	; 0x04
    1350:	01 97       	sbiw	r24, 0x01	; 1
    1352:	9c 83       	std	Y+4, r25	; 0x04
    1354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1356:	eb 81       	ldd	r30, Y+3	; 0x03
    1358:	fc 81       	ldd	r31, Y+4	; 0x04
    135a:	80 e3       	ldi	r24, 0x30	; 48
    135c:	80 83       	st	Z, r24
	pxTopOfStack--;
    135e:	8b 81       	ldd	r24, Y+3	; 0x03
    1360:	9c 81       	ldd	r25, Y+4	; 0x04
    1362:	01 97       	sbiw	r24, 0x01	; 1
    1364:	9c 83       	std	Y+4, r25	; 0x04
    1366:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1368:	eb 81       	ldd	r30, Y+3	; 0x03
    136a:	fc 81       	ldd	r31, Y+4	; 0x04
    136c:	81 e3       	ldi	r24, 0x31	; 49
    136e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1370:	8b 81       	ldd	r24, Y+3	; 0x03
    1372:	9c 81       	ldd	r25, Y+4	; 0x04
    1374:	01 97       	sbiw	r24, 0x01	; 1
    1376:	9c 83       	std	Y+4, r25	; 0x04
    1378:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    137a:	8b 81       	ldd	r24, Y+3	; 0x03
    137c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    137e:	28 96       	adiw	r28, 0x08	; 8
    1380:	0f b6       	in	r0, 0x3f	; 63
    1382:	f8 94       	cli
    1384:	de bf       	out	0x3e, r29	; 62
    1386:	0f be       	out	0x3f, r0	; 63
    1388:	cd bf       	out	0x3d, r28	; 61
    138a:	cf 91       	pop	r28
    138c:	df 91       	pop	r29
    138e:	08 95       	ret

00001390 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1390:	df 93       	push	r29
    1392:	cf 93       	push	r28
    1394:	cd b7       	in	r28, 0x3d	; 61
    1396:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1398:	0e 94 b8 0a 	call	0x1570	; 0x1570 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    139c:	a0 91 04 03 	lds	r26, 0x0304
    13a0:	b0 91 05 03 	lds	r27, 0x0305
    13a4:	cd 91       	ld	r28, X+
    13a6:	cd bf       	out	0x3d, r28	; 61
    13a8:	dd 91       	ld	r29, X+
    13aa:	de bf       	out	0x3e, r29	; 62
    13ac:	ff 91       	pop	r31
    13ae:	ef 91       	pop	r30
    13b0:	df 91       	pop	r29
    13b2:	cf 91       	pop	r28
    13b4:	bf 91       	pop	r27
    13b6:	af 91       	pop	r26
    13b8:	9f 91       	pop	r25
    13ba:	8f 91       	pop	r24
    13bc:	7f 91       	pop	r23
    13be:	6f 91       	pop	r22
    13c0:	5f 91       	pop	r21
    13c2:	4f 91       	pop	r20
    13c4:	3f 91       	pop	r19
    13c6:	2f 91       	pop	r18
    13c8:	1f 91       	pop	r17
    13ca:	0f 91       	pop	r16
    13cc:	ff 90       	pop	r15
    13ce:	ef 90       	pop	r14
    13d0:	df 90       	pop	r13
    13d2:	cf 90       	pop	r12
    13d4:	bf 90       	pop	r11
    13d6:	af 90       	pop	r10
    13d8:	9f 90       	pop	r9
    13da:	8f 90       	pop	r8
    13dc:	7f 90       	pop	r7
    13de:	6f 90       	pop	r6
    13e0:	5f 90       	pop	r5
    13e2:	4f 90       	pop	r4
    13e4:	3f 90       	pop	r3
    13e6:	2f 90       	pop	r2
    13e8:	1f 90       	pop	r1
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    13f0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    13f2:	81 e0       	ldi	r24, 0x01	; 1
}
    13f4:	cf 91       	pop	r28
    13f6:	df 91       	pop	r29
    13f8:	08 95       	ret

000013fa <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    13fa:	df 93       	push	r29
    13fc:	cf 93       	push	r28
    13fe:	cd b7       	in	r28, 0x3d	; 61
    1400:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1402:	cf 91       	pop	r28
    1404:	df 91       	pop	r29
    1406:	08 95       	ret

00001408 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1408:	0f 92       	push	r0
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	0f 92       	push	r0
    1410:	1f 92       	push	r1
    1412:	11 24       	eor	r1, r1
    1414:	2f 92       	push	r2
    1416:	3f 92       	push	r3
    1418:	4f 92       	push	r4
    141a:	5f 92       	push	r5
    141c:	6f 92       	push	r6
    141e:	7f 92       	push	r7
    1420:	8f 92       	push	r8
    1422:	9f 92       	push	r9
    1424:	af 92       	push	r10
    1426:	bf 92       	push	r11
    1428:	cf 92       	push	r12
    142a:	df 92       	push	r13
    142c:	ef 92       	push	r14
    142e:	ff 92       	push	r15
    1430:	0f 93       	push	r16
    1432:	1f 93       	push	r17
    1434:	2f 93       	push	r18
    1436:	3f 93       	push	r19
    1438:	4f 93       	push	r20
    143a:	5f 93       	push	r21
    143c:	6f 93       	push	r22
    143e:	7f 93       	push	r23
    1440:	8f 93       	push	r24
    1442:	9f 93       	push	r25
    1444:	af 93       	push	r26
    1446:	bf 93       	push	r27
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	ef 93       	push	r30
    144e:	ff 93       	push	r31
    1450:	a0 91 04 03 	lds	r26, 0x0304
    1454:	b0 91 05 03 	lds	r27, 0x0305
    1458:	0d b6       	in	r0, 0x3d	; 61
    145a:	0d 92       	st	X+, r0
    145c:	0e b6       	in	r0, 0x3e	; 62
    145e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1460:	0e 94 99 13 	call	0x2732	; 0x2732 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1464:	a0 91 04 03 	lds	r26, 0x0304
    1468:	b0 91 05 03 	lds	r27, 0x0305
    146c:	cd 91       	ld	r28, X+
    146e:	cd bf       	out	0x3d, r28	; 61
    1470:	dd 91       	ld	r29, X+
    1472:	de bf       	out	0x3e, r29	; 62
    1474:	ff 91       	pop	r31
    1476:	ef 91       	pop	r30
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	bf 91       	pop	r27
    147e:	af 91       	pop	r26
    1480:	9f 91       	pop	r25
    1482:	8f 91       	pop	r24
    1484:	7f 91       	pop	r23
    1486:	6f 91       	pop	r22
    1488:	5f 91       	pop	r21
    148a:	4f 91       	pop	r20
    148c:	3f 91       	pop	r19
    148e:	2f 91       	pop	r18
    1490:	1f 91       	pop	r17
    1492:	0f 91       	pop	r16
    1494:	ff 90       	pop	r15
    1496:	ef 90       	pop	r14
    1498:	df 90       	pop	r13
    149a:	cf 90       	pop	r12
    149c:	bf 90       	pop	r11
    149e:	af 90       	pop	r10
    14a0:	9f 90       	pop	r9
    14a2:	8f 90       	pop	r8
    14a4:	7f 90       	pop	r7
    14a6:	6f 90       	pop	r6
    14a8:	5f 90       	pop	r5
    14aa:	4f 90       	pop	r4
    14ac:	3f 90       	pop	r3
    14ae:	2f 90       	pop	r2
    14b0:	1f 90       	pop	r1
    14b2:	0f 90       	pop	r0
    14b4:	0f be       	out	0x3f, r0	; 63
    14b6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14b8:	08 95       	ret

000014ba <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14ba:	0f 92       	push	r0
    14bc:	0f b6       	in	r0, 0x3f	; 63
    14be:	f8 94       	cli
    14c0:	0f 92       	push	r0
    14c2:	1f 92       	push	r1
    14c4:	11 24       	eor	r1, r1
    14c6:	2f 92       	push	r2
    14c8:	3f 92       	push	r3
    14ca:	4f 92       	push	r4
    14cc:	5f 92       	push	r5
    14ce:	6f 92       	push	r6
    14d0:	7f 92       	push	r7
    14d2:	8f 92       	push	r8
    14d4:	9f 92       	push	r9
    14d6:	af 92       	push	r10
    14d8:	bf 92       	push	r11
    14da:	cf 92       	push	r12
    14dc:	df 92       	push	r13
    14de:	ef 92       	push	r14
    14e0:	ff 92       	push	r15
    14e2:	0f 93       	push	r16
    14e4:	1f 93       	push	r17
    14e6:	2f 93       	push	r18
    14e8:	3f 93       	push	r19
    14ea:	4f 93       	push	r20
    14ec:	5f 93       	push	r21
    14ee:	6f 93       	push	r22
    14f0:	7f 93       	push	r23
    14f2:	8f 93       	push	r24
    14f4:	9f 93       	push	r25
    14f6:	af 93       	push	r26
    14f8:	bf 93       	push	r27
    14fa:	cf 93       	push	r28
    14fc:	df 93       	push	r29
    14fe:	ef 93       	push	r30
    1500:	ff 93       	push	r31
    1502:	a0 91 04 03 	lds	r26, 0x0304
    1506:	b0 91 05 03 	lds	r27, 0x0305
    150a:	0d b6       	in	r0, 0x3d	; 61
    150c:	0d 92       	st	X+, r0
    150e:	0e b6       	in	r0, 0x3e	; 62
    1510:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1512:	0e 94 c4 12 	call	0x2588	; 0x2588 <vTaskIncrementTick>
	vTaskSwitchContext();
    1516:	0e 94 99 13 	call	0x2732	; 0x2732 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    151a:	a0 91 04 03 	lds	r26, 0x0304
    151e:	b0 91 05 03 	lds	r27, 0x0305
    1522:	cd 91       	ld	r28, X+
    1524:	cd bf       	out	0x3d, r28	; 61
    1526:	dd 91       	ld	r29, X+
    1528:	de bf       	out	0x3e, r29	; 62
    152a:	ff 91       	pop	r31
    152c:	ef 91       	pop	r30
    152e:	df 91       	pop	r29
    1530:	cf 91       	pop	r28
    1532:	bf 91       	pop	r27
    1534:	af 91       	pop	r26
    1536:	9f 91       	pop	r25
    1538:	8f 91       	pop	r24
    153a:	7f 91       	pop	r23
    153c:	6f 91       	pop	r22
    153e:	5f 91       	pop	r21
    1540:	4f 91       	pop	r20
    1542:	3f 91       	pop	r19
    1544:	2f 91       	pop	r18
    1546:	1f 91       	pop	r17
    1548:	0f 91       	pop	r16
    154a:	ff 90       	pop	r15
    154c:	ef 90       	pop	r14
    154e:	df 90       	pop	r13
    1550:	cf 90       	pop	r12
    1552:	bf 90       	pop	r11
    1554:	af 90       	pop	r10
    1556:	9f 90       	pop	r9
    1558:	8f 90       	pop	r8
    155a:	7f 90       	pop	r7
    155c:	6f 90       	pop	r6
    155e:	5f 90       	pop	r5
    1560:	4f 90       	pop	r4
    1562:	3f 90       	pop	r3
    1564:	2f 90       	pop	r2
    1566:	1f 90       	pop	r1
    1568:	0f 90       	pop	r0
    156a:	0f be       	out	0x3f, r0	; 63
    156c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    156e:	08 95       	ret

00001570 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1570:	df 93       	push	r29
    1572:	cf 93       	push	r28
    1574:	00 d0       	rcall	.+0      	; 0x1576 <prvSetupTimerInterrupt+0x6>
    1576:	00 d0       	rcall	.+0      	; 0x1578 <prvSetupTimerInterrupt+0x8>
    1578:	00 d0       	rcall	.+0      	; 0x157a <prvSetupTimerInterrupt+0xa>
    157a:	cd b7       	in	r28, 0x3d	; 61
    157c:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    157e:	80 e4       	ldi	r24, 0x40	; 64
    1580:	9f e1       	ldi	r25, 0x1F	; 31
    1582:	a0 e0       	ldi	r26, 0x00	; 0
    1584:	b0 e0       	ldi	r27, 0x00	; 0
    1586:	8b 83       	std	Y+3, r24	; 0x03
    1588:	9c 83       	std	Y+4, r25	; 0x04
    158a:	ad 83       	std	Y+5, r26	; 0x05
    158c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    158e:	8b 81       	ldd	r24, Y+3	; 0x03
    1590:	9c 81       	ldd	r25, Y+4	; 0x04
    1592:	ad 81       	ldd	r26, Y+5	; 0x05
    1594:	be 81       	ldd	r27, Y+6	; 0x06
    1596:	68 94       	set
    1598:	15 f8       	bld	r1, 5
    159a:	b6 95       	lsr	r27
    159c:	a7 95       	ror	r26
    159e:	97 95       	ror	r25
    15a0:	87 95       	ror	r24
    15a2:	16 94       	lsr	r1
    15a4:	d1 f7       	brne	.-12     	; 0x159a <prvSetupTimerInterrupt+0x2a>
    15a6:	8b 83       	std	Y+3, r24	; 0x03
    15a8:	9c 83       	std	Y+4, r25	; 0x04
    15aa:	ad 83       	std	Y+5, r26	; 0x05
    15ac:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    15ae:	8b 81       	ldd	r24, Y+3	; 0x03
    15b0:	9c 81       	ldd	r25, Y+4	; 0x04
    15b2:	ad 81       	ldd	r26, Y+5	; 0x05
    15b4:	be 81       	ldd	r27, Y+6	; 0x06
    15b6:	01 97       	sbiw	r24, 0x01	; 1
    15b8:	a1 09       	sbc	r26, r1
    15ba:	b1 09       	sbc	r27, r1
    15bc:	8b 83       	std	Y+3, r24	; 0x03
    15be:	9c 83       	std	Y+4, r25	; 0x04
    15c0:	ad 83       	std	Y+5, r26	; 0x05
    15c2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    15c4:	8b 81       	ldd	r24, Y+3	; 0x03
    15c6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    15c8:	8b 81       	ldd	r24, Y+3	; 0x03
    15ca:	9c 81       	ldd	r25, Y+4	; 0x04
    15cc:	ad 81       	ldd	r26, Y+5	; 0x05
    15ce:	be 81       	ldd	r27, Y+6	; 0x06
    15d0:	89 2f       	mov	r24, r25
    15d2:	9a 2f       	mov	r25, r26
    15d4:	ab 2f       	mov	r26, r27
    15d6:	bb 27       	eor	r27, r27
    15d8:	8b 83       	std	Y+3, r24	; 0x03
    15da:	9c 83       	std	Y+4, r25	; 0x04
    15dc:	ad 83       	std	Y+5, r26	; 0x05
    15de:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    15e0:	8b 81       	ldd	r24, Y+3	; 0x03
    15e2:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    15e4:	eb e4       	ldi	r30, 0x4B	; 75
    15e6:	f0 e0       	ldi	r31, 0x00	; 0
    15e8:	8a 81       	ldd	r24, Y+2	; 0x02
    15ea:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    15ec:	ea e4       	ldi	r30, 0x4A	; 74
    15ee:	f0 e0       	ldi	r31, 0x00	; 0
    15f0:	89 81       	ldd	r24, Y+1	; 0x01
    15f2:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    15f4:	8b e0       	ldi	r24, 0x0B	; 11
    15f6:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    15f8:	ee e4       	ldi	r30, 0x4E	; 78
    15fa:	f0 e0       	ldi	r31, 0x00	; 0
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
    15fe:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1600:	e9 e5       	ldi	r30, 0x59	; 89
    1602:	f0 e0       	ldi	r31, 0x00	; 0
    1604:	80 81       	ld	r24, Z
    1606:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1608:	89 81       	ldd	r24, Y+1	; 0x01
    160a:	80 61       	ori	r24, 0x10	; 16
    160c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    160e:	e9 e5       	ldi	r30, 0x59	; 89
    1610:	f0 e0       	ldi	r31, 0x00	; 0
    1612:	89 81       	ldd	r24, Y+1	; 0x01
    1614:	80 83       	st	Z, r24
}
    1616:	26 96       	adiw	r28, 0x06	; 6
    1618:	0f b6       	in	r0, 0x3f	; 63
    161a:	f8 94       	cli
    161c:	de bf       	out	0x3e, r29	; 62
    161e:	0f be       	out	0x3f, r0	; 63
    1620:	cd bf       	out	0x3d, r28	; 61
    1622:	cf 91       	pop	r28
    1624:	df 91       	pop	r29
    1626:	08 95       	ret

00001628 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    1628:	1f 92       	push	r1
    162a:	0f 92       	push	r0
    162c:	0f b6       	in	r0, 0x3f	; 63
    162e:	0f 92       	push	r0
    1630:	11 24       	eor	r1, r1
    1632:	2f 93       	push	r18
    1634:	3f 93       	push	r19
    1636:	4f 93       	push	r20
    1638:	5f 93       	push	r21
    163a:	6f 93       	push	r22
    163c:	7f 93       	push	r23
    163e:	8f 93       	push	r24
    1640:	9f 93       	push	r25
    1642:	af 93       	push	r26
    1644:	bf 93       	push	r27
    1646:	ef 93       	push	r30
    1648:	ff 93       	push	r31
    164a:	df 93       	push	r29
    164c:	cf 93       	push	r28
    164e:	cd b7       	in	r28, 0x3d	; 61
    1650:	de b7       	in	r29, 0x3e	; 62
		vTaskIncrementTick();
    1652:	0e 94 c4 12 	call	0x2588	; 0x2588 <vTaskIncrementTick>
	}
    1656:	cf 91       	pop	r28
    1658:	df 91       	pop	r29
    165a:	ff 91       	pop	r31
    165c:	ef 91       	pop	r30
    165e:	bf 91       	pop	r27
    1660:	af 91       	pop	r26
    1662:	9f 91       	pop	r25
    1664:	8f 91       	pop	r24
    1666:	7f 91       	pop	r23
    1668:	6f 91       	pop	r22
    166a:	5f 91       	pop	r21
    166c:	4f 91       	pop	r20
    166e:	3f 91       	pop	r19
    1670:	2f 91       	pop	r18
    1672:	0f 90       	pop	r0
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	0f 90       	pop	r0
    1678:	1f 90       	pop	r1
    167a:	18 95       	reti

0000167c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    167c:	df 93       	push	r29
    167e:	cf 93       	push	r28
    1680:	cd b7       	in	r28, 0x3d	; 61
    1682:	de b7       	in	r29, 0x3e	; 62
    1684:	28 97       	sbiw	r28, 0x08	; 8
    1686:	0f b6       	in	r0, 0x3f	; 63
    1688:	f8 94       	cli
    168a:	de bf       	out	0x3e, r29	; 62
    168c:	0f be       	out	0x3f, r0	; 63
    168e:	cd bf       	out	0x3d, r28	; 61
    1690:	8f 83       	std	Y+7, r24	; 0x07
    1692:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1694:	1a 82       	std	Y+2, r1	; 0x02
    1696:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1698:	8f 81       	ldd	r24, Y+7	; 0x07
    169a:	88 23       	and	r24, r24
    169c:	09 f4       	brne	.+2      	; 0x16a0 <xQueueCreate+0x24>
    169e:	8c c0       	rjmp	.+280    	; 0x17b8 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    16a0:	8f e1       	ldi	r24, 0x1F	; 31
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pvPortMalloc>
    16a8:	9e 83       	std	Y+6, r25	; 0x06
    16aa:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    16ac:	8d 81       	ldd	r24, Y+5	; 0x05
    16ae:	9e 81       	ldd	r25, Y+6	; 0x06
    16b0:	00 97       	sbiw	r24, 0x00	; 0
    16b2:	09 f4       	brne	.+2      	; 0x16b6 <xQueueCreate+0x3a>
    16b4:	81 c0       	rjmp	.+258    	; 0x17b8 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    16b6:	8f 81       	ldd	r24, Y+7	; 0x07
    16b8:	28 2f       	mov	r18, r24
    16ba:	30 e0       	ldi	r19, 0x00	; 0
    16bc:	88 85       	ldd	r24, Y+8	; 0x08
    16be:	88 2f       	mov	r24, r24
    16c0:	90 e0       	ldi	r25, 0x00	; 0
    16c2:	ac 01       	movw	r20, r24
    16c4:	24 9f       	mul	r18, r20
    16c6:	c0 01       	movw	r24, r0
    16c8:	25 9f       	mul	r18, r21
    16ca:	90 0d       	add	r25, r0
    16cc:	34 9f       	mul	r19, r20
    16ce:	90 0d       	add	r25, r0
    16d0:	11 24       	eor	r1, r1
    16d2:	01 96       	adiw	r24, 0x01	; 1
    16d4:	9c 83       	std	Y+4, r25	; 0x04
    16d6:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    16d8:	8b 81       	ldd	r24, Y+3	; 0x03
    16da:	9c 81       	ldd	r25, Y+4	; 0x04
    16dc:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pvPortMalloc>
    16e0:	ed 81       	ldd	r30, Y+5	; 0x05
    16e2:	fe 81       	ldd	r31, Y+6	; 0x06
    16e4:	91 83       	std	Z+1, r25	; 0x01
    16e6:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    16e8:	ed 81       	ldd	r30, Y+5	; 0x05
    16ea:	fe 81       	ldd	r31, Y+6	; 0x06
    16ec:	80 81       	ld	r24, Z
    16ee:	91 81       	ldd	r25, Z+1	; 0x01
    16f0:	00 97       	sbiw	r24, 0x00	; 0
    16f2:	09 f4       	brne	.+2      	; 0x16f6 <xQueueCreate+0x7a>
    16f4:	5d c0       	rjmp	.+186    	; 0x17b0 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    16f6:	ed 81       	ldd	r30, Y+5	; 0x05
    16f8:	fe 81       	ldd	r31, Y+6	; 0x06
    16fa:	40 81       	ld	r20, Z
    16fc:	51 81       	ldd	r21, Z+1	; 0x01
    16fe:	8f 81       	ldd	r24, Y+7	; 0x07
    1700:	28 2f       	mov	r18, r24
    1702:	30 e0       	ldi	r19, 0x00	; 0
    1704:	88 85       	ldd	r24, Y+8	; 0x08
    1706:	88 2f       	mov	r24, r24
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	bc 01       	movw	r22, r24
    170c:	26 9f       	mul	r18, r22
    170e:	c0 01       	movw	r24, r0
    1710:	27 9f       	mul	r18, r23
    1712:	90 0d       	add	r25, r0
    1714:	36 9f       	mul	r19, r22
    1716:	90 0d       	add	r25, r0
    1718:	11 24       	eor	r1, r1
    171a:	84 0f       	add	r24, r20
    171c:	95 1f       	adc	r25, r21
    171e:	ed 81       	ldd	r30, Y+5	; 0x05
    1720:	fe 81       	ldd	r31, Y+6	; 0x06
    1722:	93 83       	std	Z+3, r25	; 0x03
    1724:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1726:	ed 81       	ldd	r30, Y+5	; 0x05
    1728:	fe 81       	ldd	r31, Y+6	; 0x06
    172a:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    172c:	ed 81       	ldd	r30, Y+5	; 0x05
    172e:	fe 81       	ldd	r31, Y+6	; 0x06
    1730:	80 81       	ld	r24, Z
    1732:	91 81       	ldd	r25, Z+1	; 0x01
    1734:	ed 81       	ldd	r30, Y+5	; 0x05
    1736:	fe 81       	ldd	r31, Y+6	; 0x06
    1738:	95 83       	std	Z+5, r25	; 0x05
    173a:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    173c:	ed 81       	ldd	r30, Y+5	; 0x05
    173e:	fe 81       	ldd	r31, Y+6	; 0x06
    1740:	40 81       	ld	r20, Z
    1742:	51 81       	ldd	r21, Z+1	; 0x01
    1744:	8f 81       	ldd	r24, Y+7	; 0x07
    1746:	88 2f       	mov	r24, r24
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	9c 01       	movw	r18, r24
    174c:	21 50       	subi	r18, 0x01	; 1
    174e:	30 40       	sbci	r19, 0x00	; 0
    1750:	88 85       	ldd	r24, Y+8	; 0x08
    1752:	88 2f       	mov	r24, r24
    1754:	90 e0       	ldi	r25, 0x00	; 0
    1756:	bc 01       	movw	r22, r24
    1758:	26 9f       	mul	r18, r22
    175a:	c0 01       	movw	r24, r0
    175c:	27 9f       	mul	r18, r23
    175e:	90 0d       	add	r25, r0
    1760:	36 9f       	mul	r19, r22
    1762:	90 0d       	add	r25, r0
    1764:	11 24       	eor	r1, r1
    1766:	84 0f       	add	r24, r20
    1768:	95 1f       	adc	r25, r21
    176a:	ed 81       	ldd	r30, Y+5	; 0x05
    176c:	fe 81       	ldd	r31, Y+6	; 0x06
    176e:	97 83       	std	Z+7, r25	; 0x07
    1770:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1772:	ed 81       	ldd	r30, Y+5	; 0x05
    1774:	fe 81       	ldd	r31, Y+6	; 0x06
    1776:	8f 81       	ldd	r24, Y+7	; 0x07
    1778:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    177a:	ed 81       	ldd	r30, Y+5	; 0x05
    177c:	fe 81       	ldd	r31, Y+6	; 0x06
    177e:	88 85       	ldd	r24, Y+8	; 0x08
    1780:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1782:	ed 81       	ldd	r30, Y+5	; 0x05
    1784:	fe 81       	ldd	r31, Y+6	; 0x06
    1786:	8f ef       	ldi	r24, 0xFF	; 255
    1788:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    178a:	ed 81       	ldd	r30, Y+5	; 0x05
    178c:	fe 81       	ldd	r31, Y+6	; 0x06
    178e:	8f ef       	ldi	r24, 0xFF	; 255
    1790:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1792:	8d 81       	ldd	r24, Y+5	; 0x05
    1794:	9e 81       	ldd	r25, Y+6	; 0x06
    1796:	08 96       	adiw	r24, 0x08	; 8
    1798:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    179c:	8d 81       	ldd	r24, Y+5	; 0x05
    179e:	9e 81       	ldd	r25, Y+6	; 0x06
    17a0:	41 96       	adiw	r24, 0x11	; 17
    17a2:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    17a6:	8d 81       	ldd	r24, Y+5	; 0x05
    17a8:	9e 81       	ldd	r25, Y+6	; 0x06
    17aa:	9a 83       	std	Y+2, r25	; 0x02
    17ac:	89 83       	std	Y+1, r24	; 0x01
    17ae:	04 c0       	rjmp	.+8      	; 0x17b8 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    17b0:	8d 81       	ldd	r24, Y+5	; 0x05
    17b2:	9e 81       	ldd	r25, Y+6	; 0x06
    17b4:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    17b8:	89 81       	ldd	r24, Y+1	; 0x01
    17ba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    17bc:	28 96       	adiw	r28, 0x08	; 8
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	de bf       	out	0x3e, r29	; 62
    17c4:	0f be       	out	0x3f, r0	; 63
    17c6:	cd bf       	out	0x3d, r28	; 61
    17c8:	cf 91       	pop	r28
    17ca:	df 91       	pop	r29
    17cc:	08 95       	ret

000017ce <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    17ce:	df 93       	push	r29
    17d0:	cf 93       	push	r28
    17d2:	cd b7       	in	r28, 0x3d	; 61
    17d4:	de b7       	in	r29, 0x3e	; 62
    17d6:	2c 97       	sbiw	r28, 0x0c	; 12
    17d8:	0f b6       	in	r0, 0x3f	; 63
    17da:	f8 94       	cli
    17dc:	de bf       	out	0x3e, r29	; 62
    17de:	0f be       	out	0x3f, r0	; 63
    17e0:	cd bf       	out	0x3d, r28	; 61
    17e2:	9e 83       	std	Y+6, r25	; 0x06
    17e4:	8d 83       	std	Y+5, r24	; 0x05
    17e6:	78 87       	std	Y+8, r23	; 0x08
    17e8:	6f 83       	std	Y+7, r22	; 0x07
    17ea:	5a 87       	std	Y+10, r21	; 0x0a
    17ec:	49 87       	std	Y+9, r20	; 0x09
    17ee:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    17f0:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    17f8:	ed 81       	ldd	r30, Y+5	; 0x05
    17fa:	fe 81       	ldd	r31, Y+6	; 0x06
    17fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    17fe:	ed 81       	ldd	r30, Y+5	; 0x05
    1800:	fe 81       	ldd	r31, Y+6	; 0x06
    1802:	83 8d       	ldd	r24, Z+27	; 0x1b
    1804:	98 17       	cp	r25, r24
    1806:	d8 f4       	brcc	.+54     	; 0x183e <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1808:	8d 81       	ldd	r24, Y+5	; 0x05
    180a:	9e 81       	ldd	r25, Y+6	; 0x06
    180c:	2f 81       	ldd	r18, Y+7	; 0x07
    180e:	38 85       	ldd	r19, Y+8	; 0x08
    1810:	b9 01       	movw	r22, r18
    1812:	4b 85       	ldd	r20, Y+11	; 0x0b
    1814:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1818:	ed 81       	ldd	r30, Y+5	; 0x05
    181a:	fe 81       	ldd	r31, Y+6	; 0x06
    181c:	81 89       	ldd	r24, Z+17	; 0x11
    181e:	88 23       	and	r24, r24
    1820:	49 f0       	breq	.+18     	; 0x1834 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1822:	8d 81       	ldd	r24, Y+5	; 0x05
    1824:	9e 81       	ldd	r25, Y+6	; 0x06
    1826:	41 96       	adiw	r24, 0x11	; 17
    1828:	0e 94 35 14 	call	0x286a	; 0x286a <xTaskRemoveFromEventList>
    182c:	81 30       	cpi	r24, 0x01	; 1
    182e:	11 f4       	brne	.+4      	; 0x1834 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1830:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1834:	0f 90       	pop	r0
    1836:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1838:	81 e0       	ldi	r24, 0x01	; 1
    183a:	8c 87       	std	Y+12, r24	; 0x0c
    183c:	5c c0       	rjmp	.+184    	; 0x18f6 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    183e:	89 85       	ldd	r24, Y+9	; 0x09
    1840:	9a 85       	ldd	r25, Y+10	; 0x0a
    1842:	00 97       	sbiw	r24, 0x00	; 0
    1844:	21 f4       	brne	.+8      	; 0x184e <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    184a:	1c 86       	std	Y+12, r1	; 0x0c
    184c:	54 c0       	rjmp	.+168    	; 0x18f6 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    184e:	89 81       	ldd	r24, Y+1	; 0x01
    1850:	88 23       	and	r24, r24
    1852:	31 f4       	brne	.+12     	; 0x1860 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1854:	ce 01       	movw	r24, r28
    1856:	02 96       	adiw	r24, 0x02	; 2
    1858:	0e 94 9d 14 	call	0x293a	; 0x293a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1860:	0f 90       	pop	r0
    1862:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1864:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1868:	0f b6       	in	r0, 0x3f	; 63
    186a:	f8 94       	cli
    186c:	0f 92       	push	r0
    186e:	ed 81       	ldd	r30, Y+5	; 0x05
    1870:	fe 81       	ldd	r31, Y+6	; 0x06
    1872:	85 8d       	ldd	r24, Z+29	; 0x1d
    1874:	8f 3f       	cpi	r24, 0xFF	; 255
    1876:	19 f4       	brne	.+6      	; 0x187e <xQueueGenericSend+0xb0>
    1878:	ed 81       	ldd	r30, Y+5	; 0x05
    187a:	fe 81       	ldd	r31, Y+6	; 0x06
    187c:	15 8e       	std	Z+29, r1	; 0x1d
    187e:	ed 81       	ldd	r30, Y+5	; 0x05
    1880:	fe 81       	ldd	r31, Y+6	; 0x06
    1882:	86 8d       	ldd	r24, Z+30	; 0x1e
    1884:	8f 3f       	cpi	r24, 0xFF	; 255
    1886:	19 f4       	brne	.+6      	; 0x188e <xQueueGenericSend+0xc0>
    1888:	ed 81       	ldd	r30, Y+5	; 0x05
    188a:	fe 81       	ldd	r31, Y+6	; 0x06
    188c:	16 8e       	std	Z+30, r1	; 0x1e
    188e:	0f 90       	pop	r0
    1890:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1892:	ce 01       	movw	r24, r28
    1894:	02 96       	adiw	r24, 0x02	; 2
    1896:	9e 01       	movw	r18, r28
    1898:	27 5f       	subi	r18, 0xF7	; 247
    189a:	3f 4f       	sbci	r19, 0xFF	; 255
    189c:	b9 01       	movw	r22, r18
    189e:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskCheckForTimeOut>
    18a2:	88 23       	and	r24, r24
    18a4:	09 f5       	brne	.+66     	; 0x18e8 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18a6:	8d 81       	ldd	r24, Y+5	; 0x05
    18a8:	9e 81       	ldd	r25, Y+6	; 0x06
    18aa:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <prvIsQueueFull>
    18ae:	88 23       	and	r24, r24
    18b0:	a1 f0       	breq	.+40     	; 0x18da <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18b2:	8d 81       	ldd	r24, Y+5	; 0x05
    18b4:	9e 81       	ldd	r25, Y+6	; 0x06
    18b6:	08 96       	adiw	r24, 0x08	; 8
    18b8:	29 85       	ldd	r18, Y+9	; 0x09
    18ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    18bc:	b9 01       	movw	r22, r18
    18be:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    18c2:	8d 81       	ldd	r24, Y+5	; 0x05
    18c4:	9e 81       	ldd	r25, Y+6	; 0x06
    18c6:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    18ca:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
    18ce:	88 23       	and	r24, r24
    18d0:	09 f0       	breq	.+2      	; 0x18d4 <xQueueGenericSend+0x106>
    18d2:	8f cf       	rjmp	.-226    	; 0x17f2 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    18d4:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
    18d8:	8c cf       	rjmp	.-232    	; 0x17f2 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18da:	8d 81       	ldd	r24, Y+5	; 0x05
    18dc:	9e 81       	ldd	r25, Y+6	; 0x06
    18de:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18e2:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
    18e6:	85 cf       	rjmp	.-246    	; 0x17f2 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    18e8:	8d 81       	ldd	r24, Y+5	; 0x05
    18ea:	9e 81       	ldd	r25, Y+6	; 0x06
    18ec:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18f0:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    18f4:	1c 86       	std	Y+12, r1	; 0x0c
    18f6:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    18f8:	2c 96       	adiw	r28, 0x0c	; 12
    18fa:	0f b6       	in	r0, 0x3f	; 63
    18fc:	f8 94       	cli
    18fe:	de bf       	out	0x3e, r29	; 62
    1900:	0f be       	out	0x3f, r0	; 63
    1902:	cd bf       	out	0x3d, r28	; 61
    1904:	cf 91       	pop	r28
    1906:	df 91       	pop	r29
    1908:	08 95       	ret

0000190a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    190a:	df 93       	push	r29
    190c:	cf 93       	push	r28
    190e:	cd b7       	in	r28, 0x3d	; 61
    1910:	de b7       	in	r29, 0x3e	; 62
    1912:	29 97       	sbiw	r28, 0x09	; 9
    1914:	0f b6       	in	r0, 0x3f	; 63
    1916:	f8 94       	cli
    1918:	de bf       	out	0x3e, r29	; 62
    191a:	0f be       	out	0x3f, r0	; 63
    191c:	cd bf       	out	0x3d, r28	; 61
    191e:	9c 83       	std	Y+4, r25	; 0x04
    1920:	8b 83       	std	Y+3, r24	; 0x03
    1922:	7e 83       	std	Y+6, r23	; 0x06
    1924:	6d 83       	std	Y+5, r22	; 0x05
    1926:	58 87       	std	Y+8, r21	; 0x08
    1928:	4f 83       	std	Y+7, r20	; 0x07
    192a:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    192c:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    192e:	eb 81       	ldd	r30, Y+3	; 0x03
    1930:	fc 81       	ldd	r31, Y+4	; 0x04
    1932:	92 8d       	ldd	r25, Z+26	; 0x1a
    1934:	eb 81       	ldd	r30, Y+3	; 0x03
    1936:	fc 81       	ldd	r31, Y+4	; 0x04
    1938:	83 8d       	ldd	r24, Z+27	; 0x1b
    193a:	98 17       	cp	r25, r24
    193c:	40 f5       	brcc	.+80     	; 0x198e <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    193e:	8b 81       	ldd	r24, Y+3	; 0x03
    1940:	9c 81       	ldd	r25, Y+4	; 0x04
    1942:	2d 81       	ldd	r18, Y+5	; 0x05
    1944:	3e 81       	ldd	r19, Y+6	; 0x06
    1946:	b9 01       	movw	r22, r18
    1948:	49 85       	ldd	r20, Y+9	; 0x09
    194a:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    194e:	eb 81       	ldd	r30, Y+3	; 0x03
    1950:	fc 81       	ldd	r31, Y+4	; 0x04
    1952:	86 8d       	ldd	r24, Z+30	; 0x1e
    1954:	8f 3f       	cpi	r24, 0xFF	; 255
    1956:	89 f4       	brne	.+34     	; 0x197a <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1958:	eb 81       	ldd	r30, Y+3	; 0x03
    195a:	fc 81       	ldd	r31, Y+4	; 0x04
    195c:	81 89       	ldd	r24, Z+17	; 0x11
    195e:	88 23       	and	r24, r24
    1960:	99 f0       	breq	.+38     	; 0x1988 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1962:	8b 81       	ldd	r24, Y+3	; 0x03
    1964:	9c 81       	ldd	r25, Y+4	; 0x04
    1966:	41 96       	adiw	r24, 0x11	; 17
    1968:	0e 94 35 14 	call	0x286a	; 0x286a <xTaskRemoveFromEventList>
    196c:	88 23       	and	r24, r24
    196e:	61 f0       	breq	.+24     	; 0x1988 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1970:	ef 81       	ldd	r30, Y+7	; 0x07
    1972:	f8 85       	ldd	r31, Y+8	; 0x08
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	80 83       	st	Z, r24
    1978:	07 c0       	rjmp	.+14     	; 0x1988 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    197a:	eb 81       	ldd	r30, Y+3	; 0x03
    197c:	fc 81       	ldd	r31, Y+4	; 0x04
    197e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1980:	8f 5f       	subi	r24, 0xFF	; 255
    1982:	eb 81       	ldd	r30, Y+3	; 0x03
    1984:	fc 81       	ldd	r31, Y+4	; 0x04
    1986:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1988:	81 e0       	ldi	r24, 0x01	; 1
    198a:	8a 83       	std	Y+2, r24	; 0x02
    198c:	01 c0       	rjmp	.+2      	; 0x1990 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    198e:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1990:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1992:	29 96       	adiw	r28, 0x09	; 9
    1994:	0f b6       	in	r0, 0x3f	; 63
    1996:	f8 94       	cli
    1998:	de bf       	out	0x3e, r29	; 62
    199a:	0f be       	out	0x3f, r0	; 63
    199c:	cd bf       	out	0x3d, r28	; 61
    199e:	cf 91       	pop	r28
    19a0:	df 91       	pop	r29
    19a2:	08 95       	ret

000019a4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    19a4:	df 93       	push	r29
    19a6:	cf 93       	push	r28
    19a8:	cd b7       	in	r28, 0x3d	; 61
    19aa:	de b7       	in	r29, 0x3e	; 62
    19ac:	2e 97       	sbiw	r28, 0x0e	; 14
    19ae:	0f b6       	in	r0, 0x3f	; 63
    19b0:	f8 94       	cli
    19b2:	de bf       	out	0x3e, r29	; 62
    19b4:	0f be       	out	0x3f, r0	; 63
    19b6:	cd bf       	out	0x3d, r28	; 61
    19b8:	98 87       	std	Y+8, r25	; 0x08
    19ba:	8f 83       	std	Y+7, r24	; 0x07
    19bc:	7a 87       	std	Y+10, r23	; 0x0a
    19be:	69 87       	std	Y+9, r22	; 0x09
    19c0:	5c 87       	std	Y+12, r21	; 0x0c
    19c2:	4b 87       	std	Y+11, r20	; 0x0b
    19c4:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    19c6:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    19c8:	0f b6       	in	r0, 0x3f	; 63
    19ca:	f8 94       	cli
    19cc:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19ce:	ef 81       	ldd	r30, Y+7	; 0x07
    19d0:	f8 85       	ldd	r31, Y+8	; 0x08
    19d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    19d4:	88 23       	and	r24, r24
    19d6:	09 f4       	brne	.+2      	; 0x19da <xQueueGenericReceive+0x36>
    19d8:	3f c0       	rjmp	.+126    	; 0x1a58 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    19da:	ef 81       	ldd	r30, Y+7	; 0x07
    19dc:	f8 85       	ldd	r31, Y+8	; 0x08
    19de:	86 81       	ldd	r24, Z+6	; 0x06
    19e0:	97 81       	ldd	r25, Z+7	; 0x07
    19e2:	9a 83       	std	Y+2, r25	; 0x02
    19e4:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    19e6:	8f 81       	ldd	r24, Y+7	; 0x07
    19e8:	98 85       	ldd	r25, Y+8	; 0x08
    19ea:	29 85       	ldd	r18, Y+9	; 0x09
    19ec:	3a 85       	ldd	r19, Y+10	; 0x0a
    19ee:	b9 01       	movw	r22, r18
    19f0:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    19f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    19f6:	88 23       	and	r24, r24
    19f8:	b1 f4       	brne	.+44     	; 0x1a26 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    19fa:	ef 81       	ldd	r30, Y+7	; 0x07
    19fc:	f8 85       	ldd	r31, Y+8	; 0x08
    19fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a00:	81 50       	subi	r24, 0x01	; 1
    1a02:	ef 81       	ldd	r30, Y+7	; 0x07
    1a04:	f8 85       	ldd	r31, Y+8	; 0x08
    1a06:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a08:	ef 81       	ldd	r30, Y+7	; 0x07
    1a0a:	f8 85       	ldd	r31, Y+8	; 0x08
    1a0c:	80 85       	ldd	r24, Z+8	; 0x08
    1a0e:	88 23       	and	r24, r24
    1a10:	f1 f0       	breq	.+60     	; 0x1a4e <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a12:	8f 81       	ldd	r24, Y+7	; 0x07
    1a14:	98 85       	ldd	r25, Y+8	; 0x08
    1a16:	08 96       	adiw	r24, 0x08	; 8
    1a18:	0e 94 35 14 	call	0x286a	; 0x286a <xTaskRemoveFromEventList>
    1a1c:	81 30       	cpi	r24, 0x01	; 1
    1a1e:	b9 f4       	brne	.+46     	; 0x1a4e <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1a20:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
    1a24:	14 c0       	rjmp	.+40     	; 0x1a4e <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1a26:	ef 81       	ldd	r30, Y+7	; 0x07
    1a28:	f8 85       	ldd	r31, Y+8	; 0x08
    1a2a:	89 81       	ldd	r24, Y+1	; 0x01
    1a2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a2e:	97 83       	std	Z+7, r25	; 0x07
    1a30:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a32:	ef 81       	ldd	r30, Y+7	; 0x07
    1a34:	f8 85       	ldd	r31, Y+8	; 0x08
    1a36:	81 89       	ldd	r24, Z+17	; 0x11
    1a38:	88 23       	and	r24, r24
    1a3a:	49 f0       	breq	.+18     	; 0x1a4e <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a3c:	8f 81       	ldd	r24, Y+7	; 0x07
    1a3e:	98 85       	ldd	r25, Y+8	; 0x08
    1a40:	41 96       	adiw	r24, 0x11	; 17
    1a42:	0e 94 35 14 	call	0x286a	; 0x286a <xTaskRemoveFromEventList>
    1a46:	88 23       	and	r24, r24
    1a48:	11 f0       	breq	.+4      	; 0x1a4e <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1a4a:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1a4e:	0f 90       	pop	r0
    1a50:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a52:	81 e0       	ldi	r24, 0x01	; 1
    1a54:	8e 87       	std	Y+14, r24	; 0x0e
    1a56:	5c c0       	rjmp	.+184    	; 0x1b10 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1a58:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a5a:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a5c:	00 97       	sbiw	r24, 0x00	; 0
    1a5e:	21 f4       	brne	.+8      	; 0x1a68 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a60:	0f 90       	pop	r0
    1a62:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a64:	1e 86       	std	Y+14, r1	; 0x0e
    1a66:	54 c0       	rjmp	.+168    	; 0x1b10 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a68:	8b 81       	ldd	r24, Y+3	; 0x03
    1a6a:	88 23       	and	r24, r24
    1a6c:	31 f4       	brne	.+12     	; 0x1a7a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a6e:	ce 01       	movw	r24, r28
    1a70:	04 96       	adiw	r24, 0x04	; 4
    1a72:	0e 94 9d 14 	call	0x293a	; 0x293a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1a7a:	0f 90       	pop	r0
    1a7c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a7e:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	f8 94       	cli
    1a86:	0f 92       	push	r0
    1a88:	ef 81       	ldd	r30, Y+7	; 0x07
    1a8a:	f8 85       	ldd	r31, Y+8	; 0x08
    1a8c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a8e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a90:	19 f4       	brne	.+6      	; 0x1a98 <xQueueGenericReceive+0xf4>
    1a92:	ef 81       	ldd	r30, Y+7	; 0x07
    1a94:	f8 85       	ldd	r31, Y+8	; 0x08
    1a96:	15 8e       	std	Z+29, r1	; 0x1d
    1a98:	ef 81       	ldd	r30, Y+7	; 0x07
    1a9a:	f8 85       	ldd	r31, Y+8	; 0x08
    1a9c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a9e:	8f 3f       	cpi	r24, 0xFF	; 255
    1aa0:	19 f4       	brne	.+6      	; 0x1aa8 <xQueueGenericReceive+0x104>
    1aa2:	ef 81       	ldd	r30, Y+7	; 0x07
    1aa4:	f8 85       	ldd	r31, Y+8	; 0x08
    1aa6:	16 8e       	std	Z+30, r1	; 0x1e
    1aa8:	0f 90       	pop	r0
    1aaa:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1aac:	ce 01       	movw	r24, r28
    1aae:	04 96       	adiw	r24, 0x04	; 4
    1ab0:	9e 01       	movw	r18, r28
    1ab2:	25 5f       	subi	r18, 0xF5	; 245
    1ab4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ab6:	b9 01       	movw	r22, r18
    1ab8:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskCheckForTimeOut>
    1abc:	88 23       	and	r24, r24
    1abe:	09 f5       	brne	.+66     	; 0x1b02 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ac0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ac2:	98 85       	ldd	r25, Y+8	; 0x08
    1ac4:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <prvIsQueueEmpty>
    1ac8:	88 23       	and	r24, r24
    1aca:	a1 f0       	breq	.+40     	; 0x1af4 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1acc:	8f 81       	ldd	r24, Y+7	; 0x07
    1ace:	98 85       	ldd	r25, Y+8	; 0x08
    1ad0:	41 96       	adiw	r24, 0x11	; 17
    1ad2:	2b 85       	ldd	r18, Y+11	; 0x0b
    1ad4:	3c 85       	ldd	r19, Y+12	; 0x0c
    1ad6:	b9 01       	movw	r22, r18
    1ad8:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1adc:	8f 81       	ldd	r24, Y+7	; 0x07
    1ade:	98 85       	ldd	r25, Y+8	; 0x08
    1ae0:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ae4:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
    1ae8:	88 23       	and	r24, r24
    1aea:	09 f0       	breq	.+2      	; 0x1aee <xQueueGenericReceive+0x14a>
    1aec:	6d cf       	rjmp	.-294    	; 0x19c8 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1aee:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
    1af2:	6a cf       	rjmp	.-300    	; 0x19c8 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1af4:	8f 81       	ldd	r24, Y+7	; 0x07
    1af6:	98 85       	ldd	r25, Y+8	; 0x08
    1af8:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1afc:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
    1b00:	63 cf       	rjmp	.-314    	; 0x19c8 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b02:	8f 81       	ldd	r24, Y+7	; 0x07
    1b04:	98 85       	ldd	r25, Y+8	; 0x08
    1b06:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b0a:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b0e:	1e 86       	std	Y+14, r1	; 0x0e
    1b10:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1b12:	2e 96       	adiw	r28, 0x0e	; 14
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	cf 91       	pop	r28
    1b20:	df 91       	pop	r29
    1b22:	08 95       	ret

00001b24 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1b24:	df 93       	push	r29
    1b26:	cf 93       	push	r28
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
    1b2c:	28 97       	sbiw	r28, 0x08	; 8
    1b2e:	0f b6       	in	r0, 0x3f	; 63
    1b30:	f8 94       	cli
    1b32:	de bf       	out	0x3e, r29	; 62
    1b34:	0f be       	out	0x3f, r0	; 63
    1b36:	cd bf       	out	0x3d, r28	; 61
    1b38:	9c 83       	std	Y+4, r25	; 0x04
    1b3a:	8b 83       	std	Y+3, r24	; 0x03
    1b3c:	7e 83       	std	Y+6, r23	; 0x06
    1b3e:	6d 83       	std	Y+5, r22	; 0x05
    1b40:	58 87       	std	Y+8, r21	; 0x08
    1b42:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b44:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b46:	eb 81       	ldd	r30, Y+3	; 0x03
    1b48:	fc 81       	ldd	r31, Y+4	; 0x04
    1b4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b4c:	88 23       	and	r24, r24
    1b4e:	71 f1       	breq	.+92     	; 0x1bac <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b50:	8b 81       	ldd	r24, Y+3	; 0x03
    1b52:	9c 81       	ldd	r25, Y+4	; 0x04
    1b54:	2d 81       	ldd	r18, Y+5	; 0x05
    1b56:	3e 81       	ldd	r19, Y+6	; 0x06
    1b58:	b9 01       	movw	r22, r18
    1b5a:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1b5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b60:	fc 81       	ldd	r31, Y+4	; 0x04
    1b62:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b64:	81 50       	subi	r24, 0x01	; 1
    1b66:	eb 81       	ldd	r30, Y+3	; 0x03
    1b68:	fc 81       	ldd	r31, Y+4	; 0x04
    1b6a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b70:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b72:	8f 3f       	cpi	r24, 0xFF	; 255
    1b74:	89 f4       	brne	.+34     	; 0x1b98 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b76:	eb 81       	ldd	r30, Y+3	; 0x03
    1b78:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7a:	80 85       	ldd	r24, Z+8	; 0x08
    1b7c:	88 23       	and	r24, r24
    1b7e:	99 f0       	breq	.+38     	; 0x1ba6 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b80:	8b 81       	ldd	r24, Y+3	; 0x03
    1b82:	9c 81       	ldd	r25, Y+4	; 0x04
    1b84:	08 96       	adiw	r24, 0x08	; 8
    1b86:	0e 94 35 14 	call	0x286a	; 0x286a <xTaskRemoveFromEventList>
    1b8a:	88 23       	and	r24, r24
    1b8c:	61 f0       	breq	.+24     	; 0x1ba6 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1b8e:	ef 81       	ldd	r30, Y+7	; 0x07
    1b90:	f8 85       	ldd	r31, Y+8	; 0x08
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	80 83       	st	Z, r24
    1b96:	07 c0       	rjmp	.+14     	; 0x1ba6 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1b98:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b9e:	8f 5f       	subi	r24, 0xFF	; 255
    1ba0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ba2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ba4:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	8a 83       	std	Y+2, r24	; 0x02
    1baa:	01 c0       	rjmp	.+2      	; 0x1bae <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1bac:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1bae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1bb0:	28 96       	adiw	r28, 0x08	; 8
    1bb2:	0f b6       	in	r0, 0x3f	; 63
    1bb4:	f8 94       	cli
    1bb6:	de bf       	out	0x3e, r29	; 62
    1bb8:	0f be       	out	0x3f, r0	; 63
    1bba:	cd bf       	out	0x3d, r28	; 61
    1bbc:	cf 91       	pop	r28
    1bbe:	df 91       	pop	r29
    1bc0:	08 95       	ret

00001bc2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1bc2:	df 93       	push	r29
    1bc4:	cf 93       	push	r28
    1bc6:	00 d0       	rcall	.+0      	; 0x1bc8 <uxQueueMessagesWaiting+0x6>
    1bc8:	0f 92       	push	r0
    1bca:	cd b7       	in	r28, 0x3d	; 61
    1bcc:	de b7       	in	r29, 0x3e	; 62
    1bce:	9b 83       	std	Y+3, r25	; 0x03
    1bd0:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1bd2:	0f b6       	in	r0, 0x3f	; 63
    1bd4:	f8 94       	cli
    1bd6:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1bd8:	ea 81       	ldd	r30, Y+2	; 0x02
    1bda:	fb 81       	ldd	r31, Y+3	; 0x03
    1bdc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bde:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1be4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1be6:	0f 90       	pop	r0
    1be8:	0f 90       	pop	r0
    1bea:	0f 90       	pop	r0
    1bec:	cf 91       	pop	r28
    1bee:	df 91       	pop	r29
    1bf0:	08 95       	ret

00001bf2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1bf2:	df 93       	push	r29
    1bf4:	cf 93       	push	r28
    1bf6:	00 d0       	rcall	.+0      	; 0x1bf8 <uxQueueMessagesWaitingFromISR+0x6>
    1bf8:	0f 92       	push	r0
    1bfa:	cd b7       	in	r28, 0x3d	; 61
    1bfc:	de b7       	in	r29, 0x3e	; 62
    1bfe:	9b 83       	std	Y+3, r25	; 0x03
    1c00:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1c02:	ea 81       	ldd	r30, Y+2	; 0x02
    1c04:	fb 81       	ldd	r31, Y+3	; 0x03
    1c06:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c08:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1c0a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c0c:	0f 90       	pop	r0
    1c0e:	0f 90       	pop	r0
    1c10:	0f 90       	pop	r0
    1c12:	cf 91       	pop	r28
    1c14:	df 91       	pop	r29
    1c16:	08 95       	ret

00001c18 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1c18:	df 93       	push	r29
    1c1a:	cf 93       	push	r28
    1c1c:	00 d0       	rcall	.+0      	; 0x1c1e <vQueueDelete+0x6>
    1c1e:	cd b7       	in	r28, 0x3d	; 61
    1c20:	de b7       	in	r29, 0x3e	; 62
    1c22:	9a 83       	std	Y+2, r25	; 0x02
    1c24:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1c26:	e9 81       	ldd	r30, Y+1	; 0x01
    1c28:	fa 81       	ldd	r31, Y+2	; 0x02
    1c2a:	80 81       	ld	r24, Z
    1c2c:	91 81       	ldd	r25, Z+1	; 0x01
    1c2e:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vPortFree>
	vPortFree( pxQueue );
    1c32:	89 81       	ldd	r24, Y+1	; 0x01
    1c34:	9a 81       	ldd	r25, Y+2	; 0x02
    1c36:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vPortFree>
}
    1c3a:	0f 90       	pop	r0
    1c3c:	0f 90       	pop	r0
    1c3e:	cf 91       	pop	r28
    1c40:	df 91       	pop	r29
    1c42:	08 95       	ret

00001c44 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1c44:	df 93       	push	r29
    1c46:	cf 93       	push	r28
    1c48:	00 d0       	rcall	.+0      	; 0x1c4a <prvCopyDataToQueue+0x6>
    1c4a:	00 d0       	rcall	.+0      	; 0x1c4c <prvCopyDataToQueue+0x8>
    1c4c:	0f 92       	push	r0
    1c4e:	cd b7       	in	r28, 0x3d	; 61
    1c50:	de b7       	in	r29, 0x3e	; 62
    1c52:	9a 83       	std	Y+2, r25	; 0x02
    1c54:	89 83       	std	Y+1, r24	; 0x01
    1c56:	7c 83       	std	Y+4, r23	; 0x04
    1c58:	6b 83       	std	Y+3, r22	; 0x03
    1c5a:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1c5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c60:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c62:	88 23       	and	r24, r24
    1c64:	09 f4       	brne	.+2      	; 0x1c68 <prvCopyDataToQueue+0x24>
    1c66:	74 c0       	rjmp	.+232    	; 0x1d50 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1c68:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6a:	88 23       	and	r24, r24
    1c6c:	99 f5       	brne	.+102    	; 0x1cd4 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c70:	fa 81       	ldd	r31, Y+2	; 0x02
    1c72:	64 81       	ldd	r22, Z+4	; 0x04
    1c74:	75 81       	ldd	r23, Z+5	; 0x05
    1c76:	e9 81       	ldd	r30, Y+1	; 0x01
    1c78:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c7c:	48 2f       	mov	r20, r24
    1c7e:	50 e0       	ldi	r21, 0x00	; 0
    1c80:	2b 81       	ldd	r18, Y+3	; 0x03
    1c82:	3c 81       	ldd	r19, Y+4	; 0x04
    1c84:	cb 01       	movw	r24, r22
    1c86:	b9 01       	movw	r22, r18
    1c88:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c90:	24 81       	ldd	r18, Z+4	; 0x04
    1c92:	35 81       	ldd	r19, Z+5	; 0x05
    1c94:	e9 81       	ldd	r30, Y+1	; 0x01
    1c96:	fa 81       	ldd	r31, Y+2	; 0x02
    1c98:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c9a:	88 2f       	mov	r24, r24
    1c9c:	90 e0       	ldi	r25, 0x00	; 0
    1c9e:	82 0f       	add	r24, r18
    1ca0:	93 1f       	adc	r25, r19
    1ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca6:	95 83       	std	Z+5, r25	; 0x05
    1ca8:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1caa:	e9 81       	ldd	r30, Y+1	; 0x01
    1cac:	fa 81       	ldd	r31, Y+2	; 0x02
    1cae:	24 81       	ldd	r18, Z+4	; 0x04
    1cb0:	35 81       	ldd	r19, Z+5	; 0x05
    1cb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb6:	82 81       	ldd	r24, Z+2	; 0x02
    1cb8:	93 81       	ldd	r25, Z+3	; 0x03
    1cba:	28 17       	cp	r18, r24
    1cbc:	39 07       	cpc	r19, r25
    1cbe:	08 f4       	brcc	.+2      	; 0x1cc2 <prvCopyDataToQueue+0x7e>
    1cc0:	47 c0       	rjmp	.+142    	; 0x1d50 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1cc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1cc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1cc6:	80 81       	ld	r24, Z
    1cc8:	91 81       	ldd	r25, Z+1	; 0x01
    1cca:	e9 81       	ldd	r30, Y+1	; 0x01
    1ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cce:	95 83       	std	Z+5, r25	; 0x05
    1cd0:	84 83       	std	Z+4, r24	; 0x04
    1cd2:	3e c0       	rjmp	.+124    	; 0x1d50 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1cd4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cd6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cd8:	66 81       	ldd	r22, Z+6	; 0x06
    1cda:	77 81       	ldd	r23, Z+7	; 0x07
    1cdc:	e9 81       	ldd	r30, Y+1	; 0x01
    1cde:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ce2:	48 2f       	mov	r20, r24
    1ce4:	50 e0       	ldi	r21, 0x00	; 0
    1ce6:	2b 81       	ldd	r18, Y+3	; 0x03
    1ce8:	3c 81       	ldd	r19, Y+4	; 0x04
    1cea:	cb 01       	movw	r24, r22
    1cec:	b9 01       	movw	r22, r18
    1cee:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1cf2:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf4:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf6:	26 81       	ldd	r18, Z+6	; 0x06
    1cf8:	37 81       	ldd	r19, Z+7	; 0x07
    1cfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1cfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cfe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d00:	88 2f       	mov	r24, r24
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	90 95       	com	r25
    1d06:	81 95       	neg	r24
    1d08:	9f 4f       	sbci	r25, 0xFF	; 255
    1d0a:	82 0f       	add	r24, r18
    1d0c:	93 1f       	adc	r25, r19
    1d0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d10:	fa 81       	ldd	r31, Y+2	; 0x02
    1d12:	97 83       	std	Z+7, r25	; 0x07
    1d14:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1d16:	e9 81       	ldd	r30, Y+1	; 0x01
    1d18:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1a:	26 81       	ldd	r18, Z+6	; 0x06
    1d1c:	37 81       	ldd	r19, Z+7	; 0x07
    1d1e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d20:	fa 81       	ldd	r31, Y+2	; 0x02
    1d22:	80 81       	ld	r24, Z
    1d24:	91 81       	ldd	r25, Z+1	; 0x01
    1d26:	28 17       	cp	r18, r24
    1d28:	39 07       	cpc	r19, r25
    1d2a:	90 f4       	brcc	.+36     	; 0x1d50 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d30:	22 81       	ldd	r18, Z+2	; 0x02
    1d32:	33 81       	ldd	r19, Z+3	; 0x03
    1d34:	e9 81       	ldd	r30, Y+1	; 0x01
    1d36:	fa 81       	ldd	r31, Y+2	; 0x02
    1d38:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d3a:	88 2f       	mov	r24, r24
    1d3c:	90 e0       	ldi	r25, 0x00	; 0
    1d3e:	90 95       	com	r25
    1d40:	81 95       	neg	r24
    1d42:	9f 4f       	sbci	r25, 0xFF	; 255
    1d44:	82 0f       	add	r24, r18
    1d46:	93 1f       	adc	r25, r19
    1d48:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4c:	97 83       	std	Z+7, r25	; 0x07
    1d4e:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1d50:	e9 81       	ldd	r30, Y+1	; 0x01
    1d52:	fa 81       	ldd	r31, Y+2	; 0x02
    1d54:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d56:	8f 5f       	subi	r24, 0xFF	; 255
    1d58:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5c:	82 8f       	std	Z+26, r24	; 0x1a
}
    1d5e:	0f 90       	pop	r0
    1d60:	0f 90       	pop	r0
    1d62:	0f 90       	pop	r0
    1d64:	0f 90       	pop	r0
    1d66:	0f 90       	pop	r0
    1d68:	cf 91       	pop	r28
    1d6a:	df 91       	pop	r29
    1d6c:	08 95       	ret

00001d6e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1d6e:	df 93       	push	r29
    1d70:	cf 93       	push	r28
    1d72:	00 d0       	rcall	.+0      	; 0x1d74 <prvCopyDataFromQueue+0x6>
    1d74:	00 d0       	rcall	.+0      	; 0x1d76 <prvCopyDataFromQueue+0x8>
    1d76:	cd b7       	in	r28, 0x3d	; 61
    1d78:	de b7       	in	r29, 0x3e	; 62
    1d7a:	9a 83       	std	Y+2, r25	; 0x02
    1d7c:	89 83       	std	Y+1, r24	; 0x01
    1d7e:	7c 83       	std	Y+4, r23	; 0x04
    1d80:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1d82:	e9 81       	ldd	r30, Y+1	; 0x01
    1d84:	fa 81       	ldd	r31, Y+2	; 0x02
    1d86:	80 81       	ld	r24, Z
    1d88:	91 81       	ldd	r25, Z+1	; 0x01
    1d8a:	00 97       	sbiw	r24, 0x00	; 0
    1d8c:	89 f1       	breq	.+98     	; 0x1df0 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1d8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d90:	fa 81       	ldd	r31, Y+2	; 0x02
    1d92:	26 81       	ldd	r18, Z+6	; 0x06
    1d94:	37 81       	ldd	r19, Z+7	; 0x07
    1d96:	e9 81       	ldd	r30, Y+1	; 0x01
    1d98:	fa 81       	ldd	r31, Y+2	; 0x02
    1d9a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d9c:	88 2f       	mov	r24, r24
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	82 0f       	add	r24, r18
    1da2:	93 1f       	adc	r25, r19
    1da4:	e9 81       	ldd	r30, Y+1	; 0x01
    1da6:	fa 81       	ldd	r31, Y+2	; 0x02
    1da8:	97 83       	std	Z+7, r25	; 0x07
    1daa:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1dac:	e9 81       	ldd	r30, Y+1	; 0x01
    1dae:	fa 81       	ldd	r31, Y+2	; 0x02
    1db0:	26 81       	ldd	r18, Z+6	; 0x06
    1db2:	37 81       	ldd	r19, Z+7	; 0x07
    1db4:	e9 81       	ldd	r30, Y+1	; 0x01
    1db6:	fa 81       	ldd	r31, Y+2	; 0x02
    1db8:	82 81       	ldd	r24, Z+2	; 0x02
    1dba:	93 81       	ldd	r25, Z+3	; 0x03
    1dbc:	28 17       	cp	r18, r24
    1dbe:	39 07       	cpc	r19, r25
    1dc0:	40 f0       	brcs	.+16     	; 0x1dd2 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1dc6:	80 81       	ld	r24, Z
    1dc8:	91 81       	ldd	r25, Z+1	; 0x01
    1dca:	e9 81       	ldd	r30, Y+1	; 0x01
    1dcc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dce:	97 83       	std	Z+7, r25	; 0x07
    1dd0:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1dd2:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd4:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd6:	46 81       	ldd	r20, Z+6	; 0x06
    1dd8:	57 81       	ldd	r21, Z+7	; 0x07
    1dda:	e9 81       	ldd	r30, Y+1	; 0x01
    1ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dde:	84 8d       	ldd	r24, Z+28	; 0x1c
    1de0:	28 2f       	mov	r18, r24
    1de2:	30 e0       	ldi	r19, 0x00	; 0
    1de4:	8b 81       	ldd	r24, Y+3	; 0x03
    1de6:	9c 81       	ldd	r25, Y+4	; 0x04
    1de8:	ba 01       	movw	r22, r20
    1dea:	a9 01       	movw	r20, r18
    1dec:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <memcpy>
	}
}
    1df0:	0f 90       	pop	r0
    1df2:	0f 90       	pop	r0
    1df4:	0f 90       	pop	r0
    1df6:	0f 90       	pop	r0
    1df8:	cf 91       	pop	r28
    1dfa:	df 91       	pop	r29
    1dfc:	08 95       	ret

00001dfe <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1dfe:	df 93       	push	r29
    1e00:	cf 93       	push	r28
    1e02:	00 d0       	rcall	.+0      	; 0x1e04 <prvUnlockQueue+0x6>
    1e04:	cd b7       	in	r28, 0x3d	; 61
    1e06:	de b7       	in	r29, 0x3e	; 62
    1e08:	9a 83       	std	Y+2, r25	; 0x02
    1e0a:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1e0c:	0f b6       	in	r0, 0x3f	; 63
    1e0e:	f8 94       	cli
    1e10:	0f 92       	push	r0
    1e12:	15 c0       	rjmp	.+42     	; 0x1e3e <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e14:	e9 81       	ldd	r30, Y+1	; 0x01
    1e16:	fa 81       	ldd	r31, Y+2	; 0x02
    1e18:	81 89       	ldd	r24, Z+17	; 0x11
    1e1a:	88 23       	and	r24, r24
    1e1c:	a9 f0       	breq	.+42     	; 0x1e48 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e1e:	89 81       	ldd	r24, Y+1	; 0x01
    1e20:	9a 81       	ldd	r25, Y+2	; 0x02
    1e22:	41 96       	adiw	r24, 0x11	; 17
    1e24:	0e 94 35 14 	call	0x286a	; 0x286a <xTaskRemoveFromEventList>
    1e28:	88 23       	and	r24, r24
    1e2a:	11 f0       	breq	.+4      	; 0x1e30 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1e2c:	0e 94 13 15 	call	0x2a26	; 0x2a26 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1e30:	e9 81       	ldd	r30, Y+1	; 0x01
    1e32:	fa 81       	ldd	r31, Y+2	; 0x02
    1e34:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e36:	81 50       	subi	r24, 0x01	; 1
    1e38:	e9 81       	ldd	r30, Y+1	; 0x01
    1e3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3c:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e40:	fa 81       	ldd	r31, Y+2	; 0x02
    1e42:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e44:	18 16       	cp	r1, r24
    1e46:	34 f3       	brlt	.-52     	; 0x1e14 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1e48:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e4c:	8f ef       	ldi	r24, 0xFF	; 255
    1e4e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1e50:	0f 90       	pop	r0
    1e52:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1e54:	0f b6       	in	r0, 0x3f	; 63
    1e56:	f8 94       	cli
    1e58:	0f 92       	push	r0
    1e5a:	15 c0       	rjmp	.+42     	; 0x1e86 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e60:	80 85       	ldd	r24, Z+8	; 0x08
    1e62:	88 23       	and	r24, r24
    1e64:	a9 f0       	breq	.+42     	; 0x1e90 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e66:	89 81       	ldd	r24, Y+1	; 0x01
    1e68:	9a 81       	ldd	r25, Y+2	; 0x02
    1e6a:	08 96       	adiw	r24, 0x08	; 8
    1e6c:	0e 94 35 14 	call	0x286a	; 0x286a <xTaskRemoveFromEventList>
    1e70:	88 23       	and	r24, r24
    1e72:	11 f0       	breq	.+4      	; 0x1e78 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1e74:	0e 94 13 15 	call	0x2a26	; 0x2a26 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1e78:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e7c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e7e:	81 50       	subi	r24, 0x01	; 1
    1e80:	e9 81       	ldd	r30, Y+1	; 0x01
    1e82:	fa 81       	ldd	r31, Y+2	; 0x02
    1e84:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1e86:	e9 81       	ldd	r30, Y+1	; 0x01
    1e88:	fa 81       	ldd	r31, Y+2	; 0x02
    1e8a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e8c:	18 16       	cp	r1, r24
    1e8e:	34 f3       	brlt	.-52     	; 0x1e5c <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1e90:	e9 81       	ldd	r30, Y+1	; 0x01
    1e92:	fa 81       	ldd	r31, Y+2	; 0x02
    1e94:	8f ef       	ldi	r24, 0xFF	; 255
    1e96:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1e98:	0f 90       	pop	r0
    1e9a:	0f be       	out	0x3f, r0	; 63
}
    1e9c:	0f 90       	pop	r0
    1e9e:	0f 90       	pop	r0
    1ea0:	cf 91       	pop	r28
    1ea2:	df 91       	pop	r29
    1ea4:	08 95       	ret

00001ea6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1ea6:	df 93       	push	r29
    1ea8:	cf 93       	push	r28
    1eaa:	00 d0       	rcall	.+0      	; 0x1eac <prvIsQueueEmpty+0x6>
    1eac:	0f 92       	push	r0
    1eae:	cd b7       	in	r28, 0x3d	; 61
    1eb0:	de b7       	in	r29, 0x3e	; 62
    1eb2:	9b 83       	std	Y+3, r25	; 0x03
    1eb4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	f8 94       	cli
    1eba:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1ebc:	ea 81       	ldd	r30, Y+2	; 0x02
    1ebe:	fb 81       	ldd	r31, Y+3	; 0x03
    1ec0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec2:	19 82       	std	Y+1, r1	; 0x01
    1ec4:	88 23       	and	r24, r24
    1ec6:	11 f4       	brne	.+4      	; 0x1ecc <prvIsQueueEmpty+0x26>
    1ec8:	81 e0       	ldi	r24, 0x01	; 1
    1eca:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1ecc:	0f 90       	pop	r0
    1ece:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1ed0:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ed2:	0f 90       	pop	r0
    1ed4:	0f 90       	pop	r0
    1ed6:	0f 90       	pop	r0
    1ed8:	cf 91       	pop	r28
    1eda:	df 91       	pop	r29
    1edc:	08 95       	ret

00001ede <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1ede:	df 93       	push	r29
    1ee0:	cf 93       	push	r28
    1ee2:	00 d0       	rcall	.+0      	; 0x1ee4 <xQueueIsQueueEmptyFromISR+0x6>
    1ee4:	0f 92       	push	r0
    1ee6:	cd b7       	in	r28, 0x3d	; 61
    1ee8:	de b7       	in	r29, 0x3e	; 62
    1eea:	9b 83       	std	Y+3, r25	; 0x03
    1eec:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1eee:	ea 81       	ldd	r30, Y+2	; 0x02
    1ef0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ef2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ef4:	19 82       	std	Y+1, r1	; 0x01
    1ef6:	88 23       	and	r24, r24
    1ef8:	11 f4       	brne	.+4      	; 0x1efe <xQueueIsQueueEmptyFromISR+0x20>
    1efa:	81 e0       	ldi	r24, 0x01	; 1
    1efc:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1efe:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f00:	0f 90       	pop	r0
    1f02:	0f 90       	pop	r0
    1f04:	0f 90       	pop	r0
    1f06:	cf 91       	pop	r28
    1f08:	df 91       	pop	r29
    1f0a:	08 95       	ret

00001f0c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1f0c:	df 93       	push	r29
    1f0e:	cf 93       	push	r28
    1f10:	00 d0       	rcall	.+0      	; 0x1f12 <prvIsQueueFull+0x6>
    1f12:	0f 92       	push	r0
    1f14:	cd b7       	in	r28, 0x3d	; 61
    1f16:	de b7       	in	r29, 0x3e	; 62
    1f18:	9b 83       	std	Y+3, r25	; 0x03
    1f1a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1f1c:	0f b6       	in	r0, 0x3f	; 63
    1f1e:	f8 94       	cli
    1f20:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1f22:	ea 81       	ldd	r30, Y+2	; 0x02
    1f24:	fb 81       	ldd	r31, Y+3	; 0x03
    1f26:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f28:	ea 81       	ldd	r30, Y+2	; 0x02
    1f2a:	fb 81       	ldd	r31, Y+3	; 0x03
    1f2c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f2e:	19 82       	std	Y+1, r1	; 0x01
    1f30:	98 17       	cp	r25, r24
    1f32:	11 f4       	brne	.+4      	; 0x1f38 <prvIsQueueFull+0x2c>
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1f38:	0f 90       	pop	r0
    1f3a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1f3c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f3e:	0f 90       	pop	r0
    1f40:	0f 90       	pop	r0
    1f42:	0f 90       	pop	r0
    1f44:	cf 91       	pop	r28
    1f46:	df 91       	pop	r29
    1f48:	08 95       	ret

00001f4a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1f4a:	df 93       	push	r29
    1f4c:	cf 93       	push	r28
    1f4e:	00 d0       	rcall	.+0      	; 0x1f50 <xQueueIsQueueFullFromISR+0x6>
    1f50:	0f 92       	push	r0
    1f52:	cd b7       	in	r28, 0x3d	; 61
    1f54:	de b7       	in	r29, 0x3e	; 62
    1f56:	9b 83       	std	Y+3, r25	; 0x03
    1f58:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1f5a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f5c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f5e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f60:	ea 81       	ldd	r30, Y+2	; 0x02
    1f62:	fb 81       	ldd	r31, Y+3	; 0x03
    1f64:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f66:	19 82       	std	Y+1, r1	; 0x01
    1f68:	98 17       	cp	r25, r24
    1f6a:	11 f4       	brne	.+4      	; 0x1f70 <xQueueIsQueueFullFromISR+0x26>
    1f6c:	81 e0       	ldi	r24, 0x01	; 1
    1f6e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1f70:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f72:	0f 90       	pop	r0
    1f74:	0f 90       	pop	r0
    1f76:	0f 90       	pop	r0
    1f78:	cf 91       	pop	r28
    1f7a:	df 91       	pop	r29
    1f7c:	08 95       	ret

00001f7e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1f7e:	af 92       	push	r10
    1f80:	bf 92       	push	r11
    1f82:	cf 92       	push	r12
    1f84:	df 92       	push	r13
    1f86:	ef 92       	push	r14
    1f88:	ff 92       	push	r15
    1f8a:	0f 93       	push	r16
    1f8c:	1f 93       	push	r17
    1f8e:	df 93       	push	r29
    1f90:	cf 93       	push	r28
    1f92:	cd b7       	in	r28, 0x3d	; 61
    1f94:	de b7       	in	r29, 0x3e	; 62
    1f96:	64 97       	sbiw	r28, 0x14	; 20
    1f98:	0f b6       	in	r0, 0x3f	; 63
    1f9a:	f8 94       	cli
    1f9c:	de bf       	out	0x3e, r29	; 62
    1f9e:	0f be       	out	0x3f, r0	; 63
    1fa0:	cd bf       	out	0x3d, r28	; 61
    1fa2:	9f 83       	std	Y+7, r25	; 0x07
    1fa4:	8e 83       	std	Y+6, r24	; 0x06
    1fa6:	79 87       	std	Y+9, r23	; 0x09
    1fa8:	68 87       	std	Y+8, r22	; 0x08
    1faa:	5b 87       	std	Y+11, r21	; 0x0b
    1fac:	4a 87       	std	Y+10, r20	; 0x0a
    1fae:	3d 87       	std	Y+13, r19	; 0x0d
    1fb0:	2c 87       	std	Y+12, r18	; 0x0c
    1fb2:	0e 87       	std	Y+14, r16	; 0x0e
    1fb4:	f8 8a       	std	Y+16, r15	; 0x10
    1fb6:	ef 86       	std	Y+15, r14	; 0x0f
    1fb8:	da 8a       	std	Y+18, r13	; 0x12
    1fba:	c9 8a       	std	Y+17, r12	; 0x11
    1fbc:	bc 8a       	std	Y+20, r11	; 0x14
    1fbe:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1fc0:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fc2:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fc4:	29 89       	ldd	r18, Y+17	; 0x11
    1fc6:	3a 89       	ldd	r19, Y+18	; 0x12
    1fc8:	b9 01       	movw	r22, r18
    1fca:	0e 94 44 16 	call	0x2c88	; 0x2c88 <prvAllocateTCBAndStack>
    1fce:	9c 83       	std	Y+4, r25	; 0x04
    1fd0:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd6:	00 97       	sbiw	r24, 0x00	; 0
    1fd8:	09 f4       	brne	.+2      	; 0x1fdc <xTaskGenericCreate+0x5e>
    1fda:	99 c0       	rjmp	.+306    	; 0x210e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1fdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fde:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe0:	27 89       	ldd	r18, Z+23	; 0x17
    1fe2:	30 8d       	ldd	r19, Z+24	; 0x18
    1fe4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fe6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fe8:	01 97       	sbiw	r24, 0x01	; 1
    1fea:	82 0f       	add	r24, r18
    1fec:	93 1f       	adc	r25, r19
    1fee:	9a 83       	std	Y+2, r25	; 0x02
    1ff0:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff6:	28 85       	ldd	r18, Y+8	; 0x08
    1ff8:	39 85       	ldd	r19, Y+9	; 0x09
    1ffa:	eb 89       	ldd	r30, Y+19	; 0x13
    1ffc:	fc 89       	ldd	r31, Y+20	; 0x14
    1ffe:	aa 85       	ldd	r26, Y+10	; 0x0a
    2000:	bb 85       	ldd	r27, Y+11	; 0x0b
    2002:	b9 01       	movw	r22, r18
    2004:	4e 85       	ldd	r20, Y+14	; 0x0e
    2006:	9f 01       	movw	r18, r30
    2008:	8d 01       	movw	r16, r26
    200a:	0e 94 29 15 	call	0x2a52	; 0x2a52 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    200e:	89 81       	ldd	r24, Y+1	; 0x01
    2010:	9a 81       	ldd	r25, Y+2	; 0x02
    2012:	2e 81       	ldd	r18, Y+6	; 0x06
    2014:	3f 81       	ldd	r19, Y+7	; 0x07
    2016:	4c 85       	ldd	r20, Y+12	; 0x0c
    2018:	5d 85       	ldd	r21, Y+13	; 0x0d
    201a:	b9 01       	movw	r22, r18
    201c:	0e 94 45 08 	call	0x108a	; 0x108a <pxPortInitialiseStack>
    2020:	eb 81       	ldd	r30, Y+3	; 0x03
    2022:	fc 81       	ldd	r31, Y+4	; 0x04
    2024:	91 83       	std	Z+1, r25	; 0x01
    2026:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2028:	8f 85       	ldd	r24, Y+15	; 0x0f
    202a:	98 89       	ldd	r25, Y+16	; 0x10
    202c:	00 97       	sbiw	r24, 0x00	; 0
    202e:	31 f0       	breq	.+12     	; 0x203c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2030:	ef 85       	ldd	r30, Y+15	; 0x0f
    2032:	f8 89       	ldd	r31, Y+16	; 0x10
    2034:	8b 81       	ldd	r24, Y+3	; 0x03
    2036:	9c 81       	ldd	r25, Y+4	; 0x04
    2038:	91 83       	std	Z+1, r25	; 0x01
    203a:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    203c:	0f b6       	in	r0, 0x3f	; 63
    203e:	f8 94       	cli
    2040:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2042:	80 91 07 03 	lds	r24, 0x0307
    2046:	8f 5f       	subi	r24, 0xFF	; 255
    2048:	80 93 07 03 	sts	0x0307, r24
			if( pxCurrentTCB == NULL )
    204c:	80 91 04 03 	lds	r24, 0x0304
    2050:	90 91 05 03 	lds	r25, 0x0305
    2054:	00 97       	sbiw	r24, 0x00	; 0
    2056:	69 f4       	brne	.+26     	; 0x2072 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2058:	8b 81       	ldd	r24, Y+3	; 0x03
    205a:	9c 81       	ldd	r25, Y+4	; 0x04
    205c:	90 93 05 03 	sts	0x0305, r25
    2060:	80 93 04 03 	sts	0x0304, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2064:	80 91 07 03 	lds	r24, 0x0307
    2068:	81 30       	cpi	r24, 0x01	; 1
    206a:	a9 f4       	brne	.+42     	; 0x2096 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    206c:	0e 94 80 15 	call	0x2b00	; 0x2b00 <prvInitialiseTaskLists>
    2070:	12 c0       	rjmp	.+36     	; 0x2096 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2072:	80 91 0c 03 	lds	r24, 0x030C
    2076:	88 23       	and	r24, r24
    2078:	71 f4       	brne	.+28     	; 0x2096 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    207a:	e0 91 04 03 	lds	r30, 0x0304
    207e:	f0 91 05 03 	lds	r31, 0x0305
    2082:	96 89       	ldd	r25, Z+22	; 0x16
    2084:	8e 85       	ldd	r24, Y+14	; 0x0e
    2086:	89 17       	cp	r24, r25
    2088:	30 f0       	brcs	.+12     	; 0x2096 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    208a:	8b 81       	ldd	r24, Y+3	; 0x03
    208c:	9c 81       	ldd	r25, Y+4	; 0x04
    208e:	90 93 05 03 	sts	0x0305, r25
    2092:	80 93 04 03 	sts	0x0304, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2096:	eb 81       	ldd	r30, Y+3	; 0x03
    2098:	fc 81       	ldd	r31, Y+4	; 0x04
    209a:	96 89       	ldd	r25, Z+22	; 0x16
    209c:	80 91 0a 03 	lds	r24, 0x030A
    20a0:	89 17       	cp	r24, r25
    20a2:	28 f4       	brcc	.+10     	; 0x20ae <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    20a4:	eb 81       	ldd	r30, Y+3	; 0x03
    20a6:	fc 81       	ldd	r31, Y+4	; 0x04
    20a8:	86 89       	ldd	r24, Z+22	; 0x16
    20aa:	80 93 0a 03 	sts	0x030A, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    20ae:	80 91 11 03 	lds	r24, 0x0311
    20b2:	8f 5f       	subi	r24, 0xFF	; 255
    20b4:	80 93 11 03 	sts	0x0311, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    20b8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ba:	fc 81       	ldd	r31, Y+4	; 0x04
    20bc:	96 89       	ldd	r25, Z+22	; 0x16
    20be:	80 91 0b 03 	lds	r24, 0x030B
    20c2:	89 17       	cp	r24, r25
    20c4:	28 f4       	brcc	.+10     	; 0x20d0 <xTaskGenericCreate+0x152>
    20c6:	eb 81       	ldd	r30, Y+3	; 0x03
    20c8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ca:	86 89       	ldd	r24, Z+22	; 0x16
    20cc:	80 93 0b 03 	sts	0x030B, r24
    20d0:	eb 81       	ldd	r30, Y+3	; 0x03
    20d2:	fc 81       	ldd	r31, Y+4	; 0x04
    20d4:	86 89       	ldd	r24, Z+22	; 0x16
    20d6:	28 2f       	mov	r18, r24
    20d8:	30 e0       	ldi	r19, 0x00	; 0
    20da:	c9 01       	movw	r24, r18
    20dc:	88 0f       	add	r24, r24
    20de:	99 1f       	adc	r25, r25
    20e0:	88 0f       	add	r24, r24
    20e2:	99 1f       	adc	r25, r25
    20e4:	88 0f       	add	r24, r24
    20e6:	99 1f       	adc	r25, r25
    20e8:	82 0f       	add	r24, r18
    20ea:	93 1f       	adc	r25, r19
    20ec:	ac 01       	movw	r20, r24
    20ee:	4e 5e       	subi	r20, 0xEE	; 238
    20f0:	5c 4f       	sbci	r21, 0xFC	; 252
    20f2:	8b 81       	ldd	r24, Y+3	; 0x03
    20f4:	9c 81       	ldd	r25, Y+4	; 0x04
    20f6:	9c 01       	movw	r18, r24
    20f8:	2e 5f       	subi	r18, 0xFE	; 254
    20fa:	3f 4f       	sbci	r19, 0xFF	; 255
    20fc:	ca 01       	movw	r24, r20
    20fe:	b9 01       	movw	r22, r18
    2100:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>

			xReturn = pdPASS;
    2104:	81 e0       	ldi	r24, 0x01	; 1
    2106:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2108:	0f 90       	pop	r0
    210a:	0f be       	out	0x3f, r0	; 63
    210c:	02 c0       	rjmp	.+4      	; 0x2112 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    210e:	8f ef       	ldi	r24, 0xFF	; 255
    2110:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2112:	8d 81       	ldd	r24, Y+5	; 0x05
    2114:	81 30       	cpi	r24, 0x01	; 1
    2116:	71 f4       	brne	.+28     	; 0x2134 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2118:	80 91 0c 03 	lds	r24, 0x030C
    211c:	88 23       	and	r24, r24
    211e:	51 f0       	breq	.+20     	; 0x2134 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2120:	e0 91 04 03 	lds	r30, 0x0304
    2124:	f0 91 05 03 	lds	r31, 0x0305
    2128:	96 89       	ldd	r25, Z+22	; 0x16
    212a:	8e 85       	ldd	r24, Y+14	; 0x0e
    212c:	98 17       	cp	r25, r24
    212e:	10 f4       	brcc	.+4      	; 0x2134 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    2130:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
			}
		}
	}

	return xReturn;
    2134:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2136:	64 96       	adiw	r28, 0x14	; 20
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	de bf       	out	0x3e, r29	; 62
    213e:	0f be       	out	0x3f, r0	; 63
    2140:	cd bf       	out	0x3d, r28	; 61
    2142:	cf 91       	pop	r28
    2144:	df 91       	pop	r29
    2146:	1f 91       	pop	r17
    2148:	0f 91       	pop	r16
    214a:	ff 90       	pop	r15
    214c:	ef 90       	pop	r14
    214e:	df 90       	pop	r13
    2150:	cf 90       	pop	r12
    2152:	bf 90       	pop	r11
    2154:	af 90       	pop	r10
    2156:	08 95       	ret

00002158 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2158:	df 93       	push	r29
    215a:	cf 93       	push	r28
    215c:	00 d0       	rcall	.+0      	; 0x215e <vTaskDelete+0x6>
    215e:	00 d0       	rcall	.+0      	; 0x2160 <vTaskDelete+0x8>
    2160:	00 d0       	rcall	.+0      	; 0x2162 <vTaskDelete+0xa>
    2162:	cd b7       	in	r28, 0x3d	; 61
    2164:	de b7       	in	r29, 0x3e	; 62
    2166:	9c 83       	std	Y+4, r25	; 0x04
    2168:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    216a:	0f b6       	in	r0, 0x3f	; 63
    216c:	f8 94       	cli
    216e:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2170:	20 91 04 03 	lds	r18, 0x0304
    2174:	30 91 05 03 	lds	r19, 0x0305
    2178:	8b 81       	ldd	r24, Y+3	; 0x03
    217a:	9c 81       	ldd	r25, Y+4	; 0x04
    217c:	82 17       	cp	r24, r18
    217e:	93 07       	cpc	r25, r19
    2180:	11 f4       	brne	.+4      	; 0x2186 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    2182:	1c 82       	std	Y+4, r1	; 0x04
    2184:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2186:	8b 81       	ldd	r24, Y+3	; 0x03
    2188:	9c 81       	ldd	r25, Y+4	; 0x04
    218a:	00 97       	sbiw	r24, 0x00	; 0
    218c:	39 f4       	brne	.+14     	; 0x219c <vTaskDelete+0x44>
    218e:	80 91 04 03 	lds	r24, 0x0304
    2192:	90 91 05 03 	lds	r25, 0x0305
    2196:	9e 83       	std	Y+6, r25	; 0x06
    2198:	8d 83       	std	Y+5, r24	; 0x05
    219a:	04 c0       	rjmp	.+8      	; 0x21a4 <vTaskDelete+0x4c>
    219c:	8b 81       	ldd	r24, Y+3	; 0x03
    219e:	9c 81       	ldd	r25, Y+4	; 0x04
    21a0:	9e 83       	std	Y+6, r25	; 0x06
    21a2:	8d 83       	std	Y+5, r24	; 0x05
    21a4:	8d 81       	ldd	r24, Y+5	; 0x05
    21a6:	9e 81       	ldd	r25, Y+6	; 0x06
    21a8:	9a 83       	std	Y+2, r25	; 0x02
    21aa:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    21ac:	89 81       	ldd	r24, Y+1	; 0x01
    21ae:	9a 81       	ldd	r25, Y+2	; 0x02
    21b0:	02 96       	adiw	r24, 0x02	; 2
    21b2:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    21b6:	e9 81       	ldd	r30, Y+1	; 0x01
    21b8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ba:	84 89       	ldd	r24, Z+20	; 0x14
    21bc:	95 89       	ldd	r25, Z+21	; 0x15
    21be:	00 97       	sbiw	r24, 0x00	; 0
    21c0:	29 f0       	breq	.+10     	; 0x21cc <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    21c2:	89 81       	ldd	r24, Y+1	; 0x01
    21c4:	9a 81       	ldd	r25, Y+2	; 0x02
    21c6:	0c 96       	adiw	r24, 0x0c	; 12
    21c8:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    21cc:	89 81       	ldd	r24, Y+1	; 0x01
    21ce:	9a 81       	ldd	r25, Y+2	; 0x02
    21d0:	9c 01       	movw	r18, r24
    21d2:	2e 5f       	subi	r18, 0xFE	; 254
    21d4:	3f 4f       	sbci	r19, 0xFF	; 255
    21d6:	8e e5       	ldi	r24, 0x5E	; 94
    21d8:	93 e0       	ldi	r25, 0x03	; 3
    21da:	b9 01       	movw	r22, r18
    21dc:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    21e0:	80 91 06 03 	lds	r24, 0x0306
    21e4:	8f 5f       	subi	r24, 0xFF	; 255
    21e6:	80 93 06 03 	sts	0x0306, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    21ea:	80 91 11 03 	lds	r24, 0x0311
    21ee:	8f 5f       	subi	r24, 0xFF	; 255
    21f0:	80 93 11 03 	sts	0x0311, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    21f4:	0f 90       	pop	r0
    21f6:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    21f8:	80 91 0c 03 	lds	r24, 0x030C
    21fc:	88 23       	and	r24, r24
    21fe:	31 f0       	breq	.+12     	; 0x220c <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2200:	8b 81       	ldd	r24, Y+3	; 0x03
    2202:	9c 81       	ldd	r25, Y+4	; 0x04
    2204:	00 97       	sbiw	r24, 0x00	; 0
    2206:	11 f4       	brne	.+4      	; 0x220c <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    2208:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
			}
		}
	}
    220c:	26 96       	adiw	r28, 0x06	; 6
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	de bf       	out	0x3e, r29	; 62
    2214:	0f be       	out	0x3f, r0	; 63
    2216:	cd bf       	out	0x3d, r28	; 61
    2218:	cf 91       	pop	r28
    221a:	df 91       	pop	r29
    221c:	08 95       	ret

0000221e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    221e:	df 93       	push	r29
    2220:	cf 93       	push	r28
    2222:	cd b7       	in	r28, 0x3d	; 61
    2224:	de b7       	in	r29, 0x3e	; 62
    2226:	28 97       	sbiw	r28, 0x08	; 8
    2228:	0f b6       	in	r0, 0x3f	; 63
    222a:	f8 94       	cli
    222c:	de bf       	out	0x3e, r29	; 62
    222e:	0f be       	out	0x3f, r0	; 63
    2230:	cd bf       	out	0x3d, r28	; 61
    2232:	9e 83       	std	Y+6, r25	; 0x06
    2234:	8d 83       	std	Y+5, r24	; 0x05
    2236:	78 87       	std	Y+8, r23	; 0x08
    2238:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    223a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    223c:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2240:	ed 81       	ldd	r30, Y+5	; 0x05
    2242:	fe 81       	ldd	r31, Y+6	; 0x06
    2244:	20 81       	ld	r18, Z
    2246:	31 81       	ldd	r19, Z+1	; 0x01
    2248:	8f 81       	ldd	r24, Y+7	; 0x07
    224a:	98 85       	ldd	r25, Y+8	; 0x08
    224c:	82 0f       	add	r24, r18
    224e:	93 1f       	adc	r25, r19
    2250:	9c 83       	std	Y+4, r25	; 0x04
    2252:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2254:	ed 81       	ldd	r30, Y+5	; 0x05
    2256:	fe 81       	ldd	r31, Y+6	; 0x06
    2258:	20 81       	ld	r18, Z
    225a:	31 81       	ldd	r19, Z+1	; 0x01
    225c:	80 91 08 03 	lds	r24, 0x0308
    2260:	90 91 09 03 	lds	r25, 0x0309
    2264:	82 17       	cp	r24, r18
    2266:	93 07       	cpc	r25, r19
    2268:	a8 f4       	brcc	.+42     	; 0x2294 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    226a:	ed 81       	ldd	r30, Y+5	; 0x05
    226c:	fe 81       	ldd	r31, Y+6	; 0x06
    226e:	20 81       	ld	r18, Z
    2270:	31 81       	ldd	r19, Z+1	; 0x01
    2272:	8b 81       	ldd	r24, Y+3	; 0x03
    2274:	9c 81       	ldd	r25, Y+4	; 0x04
    2276:	82 17       	cp	r24, r18
    2278:	93 07       	cpc	r25, r19
    227a:	00 f5       	brcc	.+64     	; 0x22bc <vTaskDelayUntil+0x9e>
    227c:	20 91 08 03 	lds	r18, 0x0308
    2280:	30 91 09 03 	lds	r19, 0x0309
    2284:	8b 81       	ldd	r24, Y+3	; 0x03
    2286:	9c 81       	ldd	r25, Y+4	; 0x04
    2288:	28 17       	cp	r18, r24
    228a:	39 07       	cpc	r19, r25
    228c:	b8 f4       	brcc	.+46     	; 0x22bc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    228e:	81 e0       	ldi	r24, 0x01	; 1
    2290:	89 83       	std	Y+1, r24	; 0x01
    2292:	14 c0       	rjmp	.+40     	; 0x22bc <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2294:	ed 81       	ldd	r30, Y+5	; 0x05
    2296:	fe 81       	ldd	r31, Y+6	; 0x06
    2298:	20 81       	ld	r18, Z
    229a:	31 81       	ldd	r19, Z+1	; 0x01
    229c:	8b 81       	ldd	r24, Y+3	; 0x03
    229e:	9c 81       	ldd	r25, Y+4	; 0x04
    22a0:	82 17       	cp	r24, r18
    22a2:	93 07       	cpc	r25, r19
    22a4:	48 f0       	brcs	.+18     	; 0x22b8 <vTaskDelayUntil+0x9a>
    22a6:	20 91 08 03 	lds	r18, 0x0308
    22aa:	30 91 09 03 	lds	r19, 0x0309
    22ae:	8b 81       	ldd	r24, Y+3	; 0x03
    22b0:	9c 81       	ldd	r25, Y+4	; 0x04
    22b2:	28 17       	cp	r18, r24
    22b4:	39 07       	cpc	r19, r25
    22b6:	10 f4       	brcc	.+4      	; 0x22bc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    22b8:	81 e0       	ldi	r24, 0x01	; 1
    22ba:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22bc:	ed 81       	ldd	r30, Y+5	; 0x05
    22be:	fe 81       	ldd	r31, Y+6	; 0x06
    22c0:	8b 81       	ldd	r24, Y+3	; 0x03
    22c2:	9c 81       	ldd	r25, Y+4	; 0x04
    22c4:	91 83       	std	Z+1, r25	; 0x01
    22c6:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    22c8:	89 81       	ldd	r24, Y+1	; 0x01
    22ca:	88 23       	and	r24, r24
    22cc:	59 f0       	breq	.+22     	; 0x22e4 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    22ce:	80 91 04 03 	lds	r24, 0x0304
    22d2:	90 91 05 03 	lds	r25, 0x0305
    22d6:	02 96       	adiw	r24, 0x02	; 2
    22d8:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22dc:	8b 81       	ldd	r24, Y+3	; 0x03
    22de:	9c 81       	ldd	r25, Y+4	; 0x04
    22e0:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    22e4:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
    22e8:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22ea:	8a 81       	ldd	r24, Y+2	; 0x02
    22ec:	88 23       	and	r24, r24
    22ee:	11 f4       	brne	.+4      	; 0x22f4 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    22f0:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
		}
	}
    22f4:	28 96       	adiw	r28, 0x08	; 8
    22f6:	0f b6       	in	r0, 0x3f	; 63
    22f8:	f8 94       	cli
    22fa:	de bf       	out	0x3e, r29	; 62
    22fc:	0f be       	out	0x3f, r0	; 63
    22fe:	cd bf       	out	0x3d, r28	; 61
    2300:	cf 91       	pop	r28
    2302:	df 91       	pop	r29
    2304:	08 95       	ret

00002306 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2306:	df 93       	push	r29
    2308:	cf 93       	push	r28
    230a:	00 d0       	rcall	.+0      	; 0x230c <vTaskDelay+0x6>
    230c:	00 d0       	rcall	.+0      	; 0x230e <vTaskDelay+0x8>
    230e:	0f 92       	push	r0
    2310:	cd b7       	in	r28, 0x3d	; 61
    2312:	de b7       	in	r29, 0x3e	; 62
    2314:	9d 83       	std	Y+5, r25	; 0x05
    2316:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2318:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    231a:	8c 81       	ldd	r24, Y+4	; 0x04
    231c:	9d 81       	ldd	r25, Y+5	; 0x05
    231e:	00 97       	sbiw	r24, 0x00	; 0
    2320:	d1 f0       	breq	.+52     	; 0x2356 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2322:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2326:	20 91 08 03 	lds	r18, 0x0308
    232a:	30 91 09 03 	lds	r19, 0x0309
    232e:	8c 81       	ldd	r24, Y+4	; 0x04
    2330:	9d 81       	ldd	r25, Y+5	; 0x05
    2332:	82 0f       	add	r24, r18
    2334:	93 1f       	adc	r25, r19
    2336:	9b 83       	std	Y+3, r25	; 0x03
    2338:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    233a:	80 91 04 03 	lds	r24, 0x0304
    233e:	90 91 05 03 	lds	r25, 0x0305
    2342:	02 96       	adiw	r24, 0x02	; 2
    2344:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2348:	8a 81       	ldd	r24, Y+2	; 0x02
    234a:	9b 81       	ldd	r25, Y+3	; 0x03
    234c:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2350:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>
    2354:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2356:	89 81       	ldd	r24, Y+1	; 0x01
    2358:	88 23       	and	r24, r24
    235a:	11 f4       	brne	.+4      	; 0x2360 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    235c:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
		}
	}
    2360:	0f 90       	pop	r0
    2362:	0f 90       	pop	r0
    2364:	0f 90       	pop	r0
    2366:	0f 90       	pop	r0
    2368:	0f 90       	pop	r0
    236a:	cf 91       	pop	r28
    236c:	df 91       	pop	r29
    236e:	08 95       	ret

00002370 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2370:	af 92       	push	r10
    2372:	bf 92       	push	r11
    2374:	cf 92       	push	r12
    2376:	df 92       	push	r13
    2378:	ef 92       	push	r14
    237a:	ff 92       	push	r15
    237c:	0f 93       	push	r16
    237e:	df 93       	push	r29
    2380:	cf 93       	push	r28
    2382:	0f 92       	push	r0
    2384:	cd b7       	in	r28, 0x3d	; 61
    2386:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2388:	26 e6       	ldi	r18, 0x66	; 102
    238a:	30 e0       	ldi	r19, 0x00	; 0
    238c:	8d e1       	ldi	r24, 0x1D	; 29
    238e:	95 e1       	ldi	r25, 0x15	; 21
    2390:	b9 01       	movw	r22, r18
    2392:	45 e5       	ldi	r20, 0x55	; 85
    2394:	50 e0       	ldi	r21, 0x00	; 0
    2396:	20 e0       	ldi	r18, 0x00	; 0
    2398:	30 e0       	ldi	r19, 0x00	; 0
    239a:	00 e0       	ldi	r16, 0x00	; 0
    239c:	ee 24       	eor	r14, r14
    239e:	ff 24       	eor	r15, r15
    23a0:	cc 24       	eor	r12, r12
    23a2:	dd 24       	eor	r13, r13
    23a4:	aa 24       	eor	r10, r10
    23a6:	bb 24       	eor	r11, r11
    23a8:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xTaskGenericCreate>
    23ac:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    23ae:	89 81       	ldd	r24, Y+1	; 0x01
    23b0:	81 30       	cpi	r24, 0x01	; 1
    23b2:	51 f4       	brne	.+20     	; 0x23c8 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    23b4:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    23b6:	81 e0       	ldi	r24, 0x01	; 1
    23b8:	80 93 0c 03 	sts	0x030C, r24
		xTickCount = ( portTickType ) 0U;
    23bc:	10 92 09 03 	sts	0x0309, r1
    23c0:	10 92 08 03 	sts	0x0308, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    23c4:	0e 94 c8 09 	call	0x1390	; 0x1390 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    23c8:	0f 90       	pop	r0
    23ca:	cf 91       	pop	r28
    23cc:	df 91       	pop	r29
    23ce:	0f 91       	pop	r16
    23d0:	ff 90       	pop	r15
    23d2:	ef 90       	pop	r14
    23d4:	df 90       	pop	r13
    23d6:	cf 90       	pop	r12
    23d8:	bf 90       	pop	r11
    23da:	af 90       	pop	r10
    23dc:	08 95       	ret

000023de <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    23de:	df 93       	push	r29
    23e0:	cf 93       	push	r28
    23e2:	cd b7       	in	r28, 0x3d	; 61
    23e4:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    23e6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    23e8:	10 92 0c 03 	sts	0x030C, r1
	vPortEndScheduler();
    23ec:	0e 94 fd 09 	call	0x13fa	; 0x13fa <vPortEndScheduler>
}
    23f0:	cf 91       	pop	r28
    23f2:	df 91       	pop	r29
    23f4:	08 95       	ret

000023f6 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    23f6:	df 93       	push	r29
    23f8:	cf 93       	push	r28
    23fa:	cd b7       	in	r28, 0x3d	; 61
    23fc:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    23fe:	80 91 0d 03 	lds	r24, 0x030D
    2402:	8f 5f       	subi	r24, 0xFF	; 255
    2404:	80 93 0d 03 	sts	0x030D, r24
}
    2408:	cf 91       	pop	r28
    240a:	df 91       	pop	r29
    240c:	08 95       	ret

0000240e <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    240e:	df 93       	push	r29
    2410:	cf 93       	push	r28
    2412:	00 d0       	rcall	.+0      	; 0x2414 <xTaskResumeAll+0x6>
    2414:	00 d0       	rcall	.+0      	; 0x2416 <xTaskResumeAll+0x8>
    2416:	cd b7       	in	r28, 0x3d	; 61
    2418:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    241a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    241c:	0f b6       	in	r0, 0x3f	; 63
    241e:	f8 94       	cli
    2420:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2422:	80 91 0d 03 	lds	r24, 0x030D
    2426:	81 50       	subi	r24, 0x01	; 1
    2428:	80 93 0d 03 	sts	0x030D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    242c:	80 91 0d 03 	lds	r24, 0x030D
    2430:	88 23       	and	r24, r24
    2432:	09 f0       	breq	.+2      	; 0x2436 <xTaskResumeAll+0x28>
    2434:	6a c0       	rjmp	.+212    	; 0x250a <xTaskResumeAll+0xfc>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2436:	80 91 07 03 	lds	r24, 0x0307
    243a:	88 23       	and	r24, r24
    243c:	09 f4       	brne	.+2      	; 0x2440 <xTaskResumeAll+0x32>
    243e:	65 c0       	rjmp	.+202    	; 0x250a <xTaskResumeAll+0xfc>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2440:	19 82       	std	Y+1, r1	; 0x01
    2442:	41 c0       	rjmp	.+130    	; 0x24c6 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2444:	e0 91 5a 03 	lds	r30, 0x035A
    2448:	f0 91 5b 03 	lds	r31, 0x035B
    244c:	86 81       	ldd	r24, Z+6	; 0x06
    244e:	97 81       	ldd	r25, Z+7	; 0x07
    2450:	9c 83       	std	Y+4, r25	; 0x04
    2452:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2454:	8b 81       	ldd	r24, Y+3	; 0x03
    2456:	9c 81       	ldd	r25, Y+4	; 0x04
    2458:	0c 96       	adiw	r24, 0x0c	; 12
    245a:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    245e:	8b 81       	ldd	r24, Y+3	; 0x03
    2460:	9c 81       	ldd	r25, Y+4	; 0x04
    2462:	02 96       	adiw	r24, 0x02	; 2
    2464:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2468:	eb 81       	ldd	r30, Y+3	; 0x03
    246a:	fc 81       	ldd	r31, Y+4	; 0x04
    246c:	96 89       	ldd	r25, Z+22	; 0x16
    246e:	80 91 0b 03 	lds	r24, 0x030B
    2472:	89 17       	cp	r24, r25
    2474:	28 f4       	brcc	.+10     	; 0x2480 <xTaskResumeAll+0x72>
    2476:	eb 81       	ldd	r30, Y+3	; 0x03
    2478:	fc 81       	ldd	r31, Y+4	; 0x04
    247a:	86 89       	ldd	r24, Z+22	; 0x16
    247c:	80 93 0b 03 	sts	0x030B, r24
    2480:	eb 81       	ldd	r30, Y+3	; 0x03
    2482:	fc 81       	ldd	r31, Y+4	; 0x04
    2484:	86 89       	ldd	r24, Z+22	; 0x16
    2486:	28 2f       	mov	r18, r24
    2488:	30 e0       	ldi	r19, 0x00	; 0
    248a:	c9 01       	movw	r24, r18
    248c:	88 0f       	add	r24, r24
    248e:	99 1f       	adc	r25, r25
    2490:	88 0f       	add	r24, r24
    2492:	99 1f       	adc	r25, r25
    2494:	88 0f       	add	r24, r24
    2496:	99 1f       	adc	r25, r25
    2498:	82 0f       	add	r24, r18
    249a:	93 1f       	adc	r25, r19
    249c:	8e 5e       	subi	r24, 0xEE	; 238
    249e:	9c 4f       	sbci	r25, 0xFC	; 252
    24a0:	2b 81       	ldd	r18, Y+3	; 0x03
    24a2:	3c 81       	ldd	r19, Y+4	; 0x04
    24a4:	2e 5f       	subi	r18, 0xFE	; 254
    24a6:	3f 4f       	sbci	r19, 0xFF	; 255
    24a8:	b9 01       	movw	r22, r18
    24aa:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    24ae:	eb 81       	ldd	r30, Y+3	; 0x03
    24b0:	fc 81       	ldd	r31, Y+4	; 0x04
    24b2:	96 89       	ldd	r25, Z+22	; 0x16
    24b4:	e0 91 04 03 	lds	r30, 0x0304
    24b8:	f0 91 05 03 	lds	r31, 0x0305
    24bc:	86 89       	ldd	r24, Z+22	; 0x16
    24be:	98 17       	cp	r25, r24
    24c0:	10 f0       	brcs	.+4      	; 0x24c6 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    24c2:	81 e0       	ldi	r24, 0x01	; 1
    24c4:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    24c6:	80 91 55 03 	lds	r24, 0x0355
    24ca:	88 23       	and	r24, r24
    24cc:	09 f0       	breq	.+2      	; 0x24d0 <xTaskResumeAll+0xc2>
    24ce:	ba cf       	rjmp	.-140    	; 0x2444 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    24d0:	80 91 0e 03 	lds	r24, 0x030E
    24d4:	88 23       	and	r24, r24
    24d6:	61 f0       	breq	.+24     	; 0x24f0 <xTaskResumeAll+0xe2>
    24d8:	07 c0       	rjmp	.+14     	; 0x24e8 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    24da:	0e 94 c4 12 	call	0x2588	; 0x2588 <vTaskIncrementTick>
						--uxMissedTicks;
    24de:	80 91 0e 03 	lds	r24, 0x030E
    24e2:	81 50       	subi	r24, 0x01	; 1
    24e4:	80 93 0e 03 	sts	0x030E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    24e8:	80 91 0e 03 	lds	r24, 0x030E
    24ec:	88 23       	and	r24, r24
    24ee:	a9 f7       	brne	.-22     	; 0x24da <xTaskResumeAll+0xcc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    24f0:	89 81       	ldd	r24, Y+1	; 0x01
    24f2:	81 30       	cpi	r24, 0x01	; 1
    24f4:	21 f0       	breq	.+8      	; 0x24fe <xTaskResumeAll+0xf0>
    24f6:	80 91 0f 03 	lds	r24, 0x030F
    24fa:	81 30       	cpi	r24, 0x01	; 1
    24fc:	31 f4       	brne	.+12     	; 0x250a <xTaskResumeAll+0xfc>
				{
					xAlreadyYielded = pdTRUE;
    24fe:	81 e0       	ldi	r24, 0x01	; 1
    2500:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2502:	10 92 0f 03 	sts	0x030F, r1
					portYIELD_WITHIN_API();
    2506:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    250a:	0f 90       	pop	r0
    250c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    250e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2510:	0f 90       	pop	r0
    2512:	0f 90       	pop	r0
    2514:	0f 90       	pop	r0
    2516:	0f 90       	pop	r0
    2518:	cf 91       	pop	r28
    251a:	df 91       	pop	r29
    251c:	08 95       	ret

0000251e <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    251e:	df 93       	push	r29
    2520:	cf 93       	push	r28
    2522:	00 d0       	rcall	.+0      	; 0x2524 <xTaskGetTickCount+0x6>
    2524:	cd b7       	in	r28, 0x3d	; 61
    2526:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2528:	0f b6       	in	r0, 0x3f	; 63
    252a:	f8 94       	cli
    252c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    252e:	80 91 08 03 	lds	r24, 0x0308
    2532:	90 91 09 03 	lds	r25, 0x0309
    2536:	9a 83       	std	Y+2, r25	; 0x02
    2538:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    253a:	0f 90       	pop	r0
    253c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    253e:	89 81       	ldd	r24, Y+1	; 0x01
    2540:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2542:	0f 90       	pop	r0
    2544:	0f 90       	pop	r0
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	08 95       	ret

0000254c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    254c:	df 93       	push	r29
    254e:	cf 93       	push	r28
    2550:	00 d0       	rcall	.+0      	; 0x2552 <xTaskGetTickCountFromISR+0x6>
    2552:	0f 92       	push	r0
    2554:	cd b7       	in	r28, 0x3d	; 61
    2556:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2558:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    255a:	80 91 08 03 	lds	r24, 0x0308
    255e:	90 91 09 03 	lds	r25, 0x0309
    2562:	9b 83       	std	Y+3, r25	; 0x03
    2564:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2566:	8a 81       	ldd	r24, Y+2	; 0x02
    2568:	9b 81       	ldd	r25, Y+3	; 0x03
}
    256a:	0f 90       	pop	r0
    256c:	0f 90       	pop	r0
    256e:	0f 90       	pop	r0
    2570:	cf 91       	pop	r28
    2572:	df 91       	pop	r29
    2574:	08 95       	ret

00002576 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2576:	df 93       	push	r29
    2578:	cf 93       	push	r28
    257a:	cd b7       	in	r28, 0x3d	; 61
    257c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    257e:	80 91 07 03 	lds	r24, 0x0307
}
    2582:	cf 91       	pop	r28
    2584:	df 91       	pop	r29
    2586:	08 95       	ret

00002588 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2588:	df 93       	push	r29
    258a:	cf 93       	push	r28
    258c:	00 d0       	rcall	.+0      	; 0x258e <vTaskIncrementTick+0x6>
    258e:	00 d0       	rcall	.+0      	; 0x2590 <vTaskIncrementTick+0x8>
    2590:	00 d0       	rcall	.+0      	; 0x2592 <vTaskIncrementTick+0xa>
    2592:	cd b7       	in	r28, 0x3d	; 61
    2594:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2596:	80 91 0d 03 	lds	r24, 0x030D
    259a:	88 23       	and	r24, r24
    259c:	09 f0       	breq	.+2      	; 0x25a0 <vTaskIncrementTick+0x18>
    259e:	bb c0       	rjmp	.+374    	; 0x2716 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    25a0:	80 91 08 03 	lds	r24, 0x0308
    25a4:	90 91 09 03 	lds	r25, 0x0309
    25a8:	01 96       	adiw	r24, 0x01	; 1
    25aa:	90 93 09 03 	sts	0x0309, r25
    25ae:	80 93 08 03 	sts	0x0308, r24
		if( xTickCount == ( portTickType ) 0U )
    25b2:	80 91 08 03 	lds	r24, 0x0308
    25b6:	90 91 09 03 	lds	r25, 0x0309
    25ba:	00 97       	sbiw	r24, 0x00	; 0
    25bc:	d1 f5       	brne	.+116    	; 0x2632 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    25be:	80 91 51 03 	lds	r24, 0x0351
    25c2:	90 91 52 03 	lds	r25, 0x0352
    25c6:	9c 83       	std	Y+4, r25	; 0x04
    25c8:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    25ca:	80 91 53 03 	lds	r24, 0x0353
    25ce:	90 91 54 03 	lds	r25, 0x0354
    25d2:	90 93 52 03 	sts	0x0352, r25
    25d6:	80 93 51 03 	sts	0x0351, r24
			pxOverflowDelayedTaskList = pxTemp;
    25da:	8b 81       	ldd	r24, Y+3	; 0x03
    25dc:	9c 81       	ldd	r25, Y+4	; 0x04
    25de:	90 93 54 03 	sts	0x0354, r25
    25e2:	80 93 53 03 	sts	0x0353, r24
			xNumOfOverflows++;
    25e6:	80 91 10 03 	lds	r24, 0x0310
    25ea:	8f 5f       	subi	r24, 0xFF	; 255
    25ec:	80 93 10 03 	sts	0x0310, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    25f0:	e0 91 51 03 	lds	r30, 0x0351
    25f4:	f0 91 52 03 	lds	r31, 0x0352
    25f8:	80 81       	ld	r24, Z
    25fa:	88 23       	and	r24, r24
    25fc:	39 f4       	brne	.+14     	; 0x260c <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    25fe:	8f ef       	ldi	r24, 0xFF	; 255
    2600:	9f ef       	ldi	r25, 0xFF	; 255
    2602:	90 93 6c 00 	sts	0x006C, r25
    2606:	80 93 6b 00 	sts	0x006B, r24
    260a:	13 c0       	rjmp	.+38     	; 0x2632 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    260c:	e0 91 51 03 	lds	r30, 0x0351
    2610:	f0 91 52 03 	lds	r31, 0x0352
    2614:	05 80       	ldd	r0, Z+5	; 0x05
    2616:	f6 81       	ldd	r31, Z+6	; 0x06
    2618:	e0 2d       	mov	r30, r0
    261a:	86 81       	ldd	r24, Z+6	; 0x06
    261c:	97 81       	ldd	r25, Z+7	; 0x07
    261e:	9e 83       	std	Y+6, r25	; 0x06
    2620:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2622:	ed 81       	ldd	r30, Y+5	; 0x05
    2624:	fe 81       	ldd	r31, Y+6	; 0x06
    2626:	82 81       	ldd	r24, Z+2	; 0x02
    2628:	93 81       	ldd	r25, Z+3	; 0x03
    262a:	90 93 6c 00 	sts	0x006C, r25
    262e:	80 93 6b 00 	sts	0x006B, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2632:	20 91 08 03 	lds	r18, 0x0308
    2636:	30 91 09 03 	lds	r19, 0x0309
    263a:	80 91 6b 00 	lds	r24, 0x006B
    263e:	90 91 6c 00 	lds	r25, 0x006C
    2642:	28 17       	cp	r18, r24
    2644:	39 07       	cpc	r19, r25
    2646:	08 f4       	brcc	.+2      	; 0x264a <vTaskIncrementTick+0xc2>
    2648:	6b c0       	rjmp	.+214    	; 0x2720 <vTaskIncrementTick+0x198>
    264a:	e0 91 51 03 	lds	r30, 0x0351
    264e:	f0 91 52 03 	lds	r31, 0x0352
    2652:	80 81       	ld	r24, Z
    2654:	88 23       	and	r24, r24
    2656:	39 f4       	brne	.+14     	; 0x2666 <vTaskIncrementTick+0xde>
    2658:	8f ef       	ldi	r24, 0xFF	; 255
    265a:	9f ef       	ldi	r25, 0xFF	; 255
    265c:	90 93 6c 00 	sts	0x006C, r25
    2660:	80 93 6b 00 	sts	0x006B, r24
    2664:	5d c0       	rjmp	.+186    	; 0x2720 <vTaskIncrementTick+0x198>
    2666:	e0 91 51 03 	lds	r30, 0x0351
    266a:	f0 91 52 03 	lds	r31, 0x0352
    266e:	05 80       	ldd	r0, Z+5	; 0x05
    2670:	f6 81       	ldd	r31, Z+6	; 0x06
    2672:	e0 2d       	mov	r30, r0
    2674:	86 81       	ldd	r24, Z+6	; 0x06
    2676:	97 81       	ldd	r25, Z+7	; 0x07
    2678:	9e 83       	std	Y+6, r25	; 0x06
    267a:	8d 83       	std	Y+5, r24	; 0x05
    267c:	ed 81       	ldd	r30, Y+5	; 0x05
    267e:	fe 81       	ldd	r31, Y+6	; 0x06
    2680:	82 81       	ldd	r24, Z+2	; 0x02
    2682:	93 81       	ldd	r25, Z+3	; 0x03
    2684:	9a 83       	std	Y+2, r25	; 0x02
    2686:	89 83       	std	Y+1, r24	; 0x01
    2688:	20 91 08 03 	lds	r18, 0x0308
    268c:	30 91 09 03 	lds	r19, 0x0309
    2690:	89 81       	ldd	r24, Y+1	; 0x01
    2692:	9a 81       	ldd	r25, Y+2	; 0x02
    2694:	28 17       	cp	r18, r24
    2696:	39 07       	cpc	r19, r25
    2698:	38 f4       	brcc	.+14     	; 0x26a8 <vTaskIncrementTick+0x120>
    269a:	89 81       	ldd	r24, Y+1	; 0x01
    269c:	9a 81       	ldd	r25, Y+2	; 0x02
    269e:	90 93 6c 00 	sts	0x006C, r25
    26a2:	80 93 6b 00 	sts	0x006B, r24
    26a6:	3c c0       	rjmp	.+120    	; 0x2720 <vTaskIncrementTick+0x198>
    26a8:	8d 81       	ldd	r24, Y+5	; 0x05
    26aa:	9e 81       	ldd	r25, Y+6	; 0x06
    26ac:	02 96       	adiw	r24, 0x02	; 2
    26ae:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
    26b2:	ed 81       	ldd	r30, Y+5	; 0x05
    26b4:	fe 81       	ldd	r31, Y+6	; 0x06
    26b6:	84 89       	ldd	r24, Z+20	; 0x14
    26b8:	95 89       	ldd	r25, Z+21	; 0x15
    26ba:	00 97       	sbiw	r24, 0x00	; 0
    26bc:	29 f0       	breq	.+10     	; 0x26c8 <vTaskIncrementTick+0x140>
    26be:	8d 81       	ldd	r24, Y+5	; 0x05
    26c0:	9e 81       	ldd	r25, Y+6	; 0x06
    26c2:	0c 96       	adiw	r24, 0x0c	; 12
    26c4:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
    26c8:	ed 81       	ldd	r30, Y+5	; 0x05
    26ca:	fe 81       	ldd	r31, Y+6	; 0x06
    26cc:	96 89       	ldd	r25, Z+22	; 0x16
    26ce:	80 91 0b 03 	lds	r24, 0x030B
    26d2:	89 17       	cp	r24, r25
    26d4:	28 f4       	brcc	.+10     	; 0x26e0 <vTaskIncrementTick+0x158>
    26d6:	ed 81       	ldd	r30, Y+5	; 0x05
    26d8:	fe 81       	ldd	r31, Y+6	; 0x06
    26da:	86 89       	ldd	r24, Z+22	; 0x16
    26dc:	80 93 0b 03 	sts	0x030B, r24
    26e0:	ed 81       	ldd	r30, Y+5	; 0x05
    26e2:	fe 81       	ldd	r31, Y+6	; 0x06
    26e4:	86 89       	ldd	r24, Z+22	; 0x16
    26e6:	28 2f       	mov	r18, r24
    26e8:	30 e0       	ldi	r19, 0x00	; 0
    26ea:	c9 01       	movw	r24, r18
    26ec:	88 0f       	add	r24, r24
    26ee:	99 1f       	adc	r25, r25
    26f0:	88 0f       	add	r24, r24
    26f2:	99 1f       	adc	r25, r25
    26f4:	88 0f       	add	r24, r24
    26f6:	99 1f       	adc	r25, r25
    26f8:	82 0f       	add	r24, r18
    26fa:	93 1f       	adc	r25, r19
    26fc:	ac 01       	movw	r20, r24
    26fe:	4e 5e       	subi	r20, 0xEE	; 238
    2700:	5c 4f       	sbci	r21, 0xFC	; 252
    2702:	8d 81       	ldd	r24, Y+5	; 0x05
    2704:	9e 81       	ldd	r25, Y+6	; 0x06
    2706:	9c 01       	movw	r18, r24
    2708:	2e 5f       	subi	r18, 0xFE	; 254
    270a:	3f 4f       	sbci	r19, 0xFF	; 255
    270c:	ca 01       	movw	r24, r20
    270e:	b9 01       	movw	r22, r18
    2710:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>
    2714:	9a cf       	rjmp	.-204    	; 0x264a <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2716:	80 91 0e 03 	lds	r24, 0x030E
    271a:	8f 5f       	subi	r24, 0xFF	; 255
    271c:	80 93 0e 03 	sts	0x030E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2720:	26 96       	adiw	r28, 0x06	; 6
    2722:	0f b6       	in	r0, 0x3f	; 63
    2724:	f8 94       	cli
    2726:	de bf       	out	0x3e, r29	; 62
    2728:	0f be       	out	0x3f, r0	; 63
    272a:	cd bf       	out	0x3d, r28	; 61
    272c:	cf 91       	pop	r28
    272e:	df 91       	pop	r29
    2730:	08 95       	ret

00002732 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2732:	df 93       	push	r29
    2734:	cf 93       	push	r28
    2736:	00 d0       	rcall	.+0      	; 0x2738 <vTaskSwitchContext+0x6>
    2738:	cd b7       	in	r28, 0x3d	; 61
    273a:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    273c:	80 91 0d 03 	lds	r24, 0x030D
    2740:	88 23       	and	r24, r24
    2742:	49 f0       	breq	.+18     	; 0x2756 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2744:	81 e0       	ldi	r24, 0x01	; 1
    2746:	80 93 0f 03 	sts	0x030F, r24
    274a:	54 c0       	rjmp	.+168    	; 0x27f4 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    274c:	80 91 0b 03 	lds	r24, 0x030B
    2750:	81 50       	subi	r24, 0x01	; 1
    2752:	80 93 0b 03 	sts	0x030B, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2756:	80 91 0b 03 	lds	r24, 0x030B
    275a:	28 2f       	mov	r18, r24
    275c:	30 e0       	ldi	r19, 0x00	; 0
    275e:	c9 01       	movw	r24, r18
    2760:	88 0f       	add	r24, r24
    2762:	99 1f       	adc	r25, r25
    2764:	88 0f       	add	r24, r24
    2766:	99 1f       	adc	r25, r25
    2768:	88 0f       	add	r24, r24
    276a:	99 1f       	adc	r25, r25
    276c:	82 0f       	add	r24, r18
    276e:	93 1f       	adc	r25, r19
    2770:	fc 01       	movw	r30, r24
    2772:	ee 5e       	subi	r30, 0xEE	; 238
    2774:	fc 4f       	sbci	r31, 0xFC	; 252
    2776:	80 81       	ld	r24, Z
    2778:	88 23       	and	r24, r24
    277a:	41 f3       	breq	.-48     	; 0x274c <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    277c:	80 91 0b 03 	lds	r24, 0x030B
    2780:	28 2f       	mov	r18, r24
    2782:	30 e0       	ldi	r19, 0x00	; 0
    2784:	c9 01       	movw	r24, r18
    2786:	88 0f       	add	r24, r24
    2788:	99 1f       	adc	r25, r25
    278a:	88 0f       	add	r24, r24
    278c:	99 1f       	adc	r25, r25
    278e:	88 0f       	add	r24, r24
    2790:	99 1f       	adc	r25, r25
    2792:	82 0f       	add	r24, r18
    2794:	93 1f       	adc	r25, r19
    2796:	8e 5e       	subi	r24, 0xEE	; 238
    2798:	9c 4f       	sbci	r25, 0xFC	; 252
    279a:	9a 83       	std	Y+2, r25	; 0x02
    279c:	89 83       	std	Y+1, r24	; 0x01
    279e:	e9 81       	ldd	r30, Y+1	; 0x01
    27a0:	fa 81       	ldd	r31, Y+2	; 0x02
    27a2:	01 80       	ldd	r0, Z+1	; 0x01
    27a4:	f2 81       	ldd	r31, Z+2	; 0x02
    27a6:	e0 2d       	mov	r30, r0
    27a8:	82 81       	ldd	r24, Z+2	; 0x02
    27aa:	93 81       	ldd	r25, Z+3	; 0x03
    27ac:	e9 81       	ldd	r30, Y+1	; 0x01
    27ae:	fa 81       	ldd	r31, Y+2	; 0x02
    27b0:	92 83       	std	Z+2, r25	; 0x02
    27b2:	81 83       	std	Z+1, r24	; 0x01
    27b4:	e9 81       	ldd	r30, Y+1	; 0x01
    27b6:	fa 81       	ldd	r31, Y+2	; 0x02
    27b8:	21 81       	ldd	r18, Z+1	; 0x01
    27ba:	32 81       	ldd	r19, Z+2	; 0x02
    27bc:	89 81       	ldd	r24, Y+1	; 0x01
    27be:	9a 81       	ldd	r25, Y+2	; 0x02
    27c0:	03 96       	adiw	r24, 0x03	; 3
    27c2:	28 17       	cp	r18, r24
    27c4:	39 07       	cpc	r19, r25
    27c6:	59 f4       	brne	.+22     	; 0x27de <vTaskSwitchContext+0xac>
    27c8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ca:	fa 81       	ldd	r31, Y+2	; 0x02
    27cc:	01 80       	ldd	r0, Z+1	; 0x01
    27ce:	f2 81       	ldd	r31, Z+2	; 0x02
    27d0:	e0 2d       	mov	r30, r0
    27d2:	82 81       	ldd	r24, Z+2	; 0x02
    27d4:	93 81       	ldd	r25, Z+3	; 0x03
    27d6:	e9 81       	ldd	r30, Y+1	; 0x01
    27d8:	fa 81       	ldd	r31, Y+2	; 0x02
    27da:	92 83       	std	Z+2, r25	; 0x02
    27dc:	81 83       	std	Z+1, r24	; 0x01
    27de:	e9 81       	ldd	r30, Y+1	; 0x01
    27e0:	fa 81       	ldd	r31, Y+2	; 0x02
    27e2:	01 80       	ldd	r0, Z+1	; 0x01
    27e4:	f2 81       	ldd	r31, Z+2	; 0x02
    27e6:	e0 2d       	mov	r30, r0
    27e8:	86 81       	ldd	r24, Z+6	; 0x06
    27ea:	97 81       	ldd	r25, Z+7	; 0x07
    27ec:	90 93 05 03 	sts	0x0305, r25
    27f0:	80 93 04 03 	sts	0x0304, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    27f4:	0f 90       	pop	r0
    27f6:	0f 90       	pop	r0
    27f8:	cf 91       	pop	r28
    27fa:	df 91       	pop	r29
    27fc:	08 95       	ret

000027fe <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    27fe:	df 93       	push	r29
    2800:	cf 93       	push	r28
    2802:	00 d0       	rcall	.+0      	; 0x2804 <vTaskPlaceOnEventList+0x6>
    2804:	00 d0       	rcall	.+0      	; 0x2806 <vTaskPlaceOnEventList+0x8>
    2806:	00 d0       	rcall	.+0      	; 0x2808 <vTaskPlaceOnEventList+0xa>
    2808:	cd b7       	in	r28, 0x3d	; 61
    280a:	de b7       	in	r29, 0x3e	; 62
    280c:	9c 83       	std	Y+4, r25	; 0x04
    280e:	8b 83       	std	Y+3, r24	; 0x03
    2810:	7e 83       	std	Y+6, r23	; 0x06
    2812:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2814:	4b 81       	ldd	r20, Y+3	; 0x03
    2816:	5c 81       	ldd	r21, Y+4	; 0x04
    2818:	80 91 04 03 	lds	r24, 0x0304
    281c:	90 91 05 03 	lds	r25, 0x0305
    2820:	9c 01       	movw	r18, r24
    2822:	24 5f       	subi	r18, 0xF4	; 244
    2824:	3f 4f       	sbci	r19, 0xFF	; 255
    2826:	ca 01       	movw	r24, r20
    2828:	b9 01       	movw	r22, r18
    282a:	0e 94 90 07 	call	0xf20	; 0xf20 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    282e:	80 91 04 03 	lds	r24, 0x0304
    2832:	90 91 05 03 	lds	r25, 0x0305
    2836:	02 96       	adiw	r24, 0x02	; 2
    2838:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    283c:	20 91 08 03 	lds	r18, 0x0308
    2840:	30 91 09 03 	lds	r19, 0x0309
    2844:	8d 81       	ldd	r24, Y+5	; 0x05
    2846:	9e 81       	ldd	r25, Y+6	; 0x06
    2848:	82 0f       	add	r24, r18
    284a:	93 1f       	adc	r25, r19
    284c:	9a 83       	std	Y+2, r25	; 0x02
    284e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2850:	89 81       	ldd	r24, Y+1	; 0x01
    2852:	9a 81       	ldd	r25, Y+2	; 0x02
    2854:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2858:	26 96       	adiw	r28, 0x06	; 6
    285a:	0f b6       	in	r0, 0x3f	; 63
    285c:	f8 94       	cli
    285e:	de bf       	out	0x3e, r29	; 62
    2860:	0f be       	out	0x3f, r0	; 63
    2862:	cd bf       	out	0x3d, r28	; 61
    2864:	cf 91       	pop	r28
    2866:	df 91       	pop	r29
    2868:	08 95       	ret

0000286a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    286a:	df 93       	push	r29
    286c:	cf 93       	push	r28
    286e:	00 d0       	rcall	.+0      	; 0x2870 <xTaskRemoveFromEventList+0x6>
    2870:	00 d0       	rcall	.+0      	; 0x2872 <xTaskRemoveFromEventList+0x8>
    2872:	0f 92       	push	r0
    2874:	cd b7       	in	r28, 0x3d	; 61
    2876:	de b7       	in	r29, 0x3e	; 62
    2878:	9d 83       	std	Y+5, r25	; 0x05
    287a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    287c:	ec 81       	ldd	r30, Y+4	; 0x04
    287e:	fd 81       	ldd	r31, Y+5	; 0x05
    2880:	05 80       	ldd	r0, Z+5	; 0x05
    2882:	f6 81       	ldd	r31, Z+6	; 0x06
    2884:	e0 2d       	mov	r30, r0
    2886:	86 81       	ldd	r24, Z+6	; 0x06
    2888:	97 81       	ldd	r25, Z+7	; 0x07
    288a:	9b 83       	std	Y+3, r25	; 0x03
    288c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    288e:	8a 81       	ldd	r24, Y+2	; 0x02
    2890:	9b 81       	ldd	r25, Y+3	; 0x03
    2892:	0c 96       	adiw	r24, 0x0c	; 12
    2894:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2898:	80 91 0d 03 	lds	r24, 0x030D
    289c:	88 23       	and	r24, r24
    289e:	61 f5       	brne	.+88     	; 0x28f8 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    28a0:	8a 81       	ldd	r24, Y+2	; 0x02
    28a2:	9b 81       	ldd	r25, Y+3	; 0x03
    28a4:	02 96       	adiw	r24, 0x02	; 2
    28a6:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    28aa:	ea 81       	ldd	r30, Y+2	; 0x02
    28ac:	fb 81       	ldd	r31, Y+3	; 0x03
    28ae:	96 89       	ldd	r25, Z+22	; 0x16
    28b0:	80 91 0b 03 	lds	r24, 0x030B
    28b4:	89 17       	cp	r24, r25
    28b6:	28 f4       	brcc	.+10     	; 0x28c2 <xTaskRemoveFromEventList+0x58>
    28b8:	ea 81       	ldd	r30, Y+2	; 0x02
    28ba:	fb 81       	ldd	r31, Y+3	; 0x03
    28bc:	86 89       	ldd	r24, Z+22	; 0x16
    28be:	80 93 0b 03 	sts	0x030B, r24
    28c2:	ea 81       	ldd	r30, Y+2	; 0x02
    28c4:	fb 81       	ldd	r31, Y+3	; 0x03
    28c6:	86 89       	ldd	r24, Z+22	; 0x16
    28c8:	28 2f       	mov	r18, r24
    28ca:	30 e0       	ldi	r19, 0x00	; 0
    28cc:	c9 01       	movw	r24, r18
    28ce:	88 0f       	add	r24, r24
    28d0:	99 1f       	adc	r25, r25
    28d2:	88 0f       	add	r24, r24
    28d4:	99 1f       	adc	r25, r25
    28d6:	88 0f       	add	r24, r24
    28d8:	99 1f       	adc	r25, r25
    28da:	82 0f       	add	r24, r18
    28dc:	93 1f       	adc	r25, r19
    28de:	ac 01       	movw	r20, r24
    28e0:	4e 5e       	subi	r20, 0xEE	; 238
    28e2:	5c 4f       	sbci	r21, 0xFC	; 252
    28e4:	8a 81       	ldd	r24, Y+2	; 0x02
    28e6:	9b 81       	ldd	r25, Y+3	; 0x03
    28e8:	9c 01       	movw	r18, r24
    28ea:	2e 5f       	subi	r18, 0xFE	; 254
    28ec:	3f 4f       	sbci	r19, 0xFF	; 255
    28ee:	ca 01       	movw	r24, r20
    28f0:	b9 01       	movw	r22, r18
    28f2:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>
    28f6:	0a c0       	rjmp	.+20     	; 0x290c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    28f8:	8a 81       	ldd	r24, Y+2	; 0x02
    28fa:	9b 81       	ldd	r25, Y+3	; 0x03
    28fc:	9c 01       	movw	r18, r24
    28fe:	24 5f       	subi	r18, 0xF4	; 244
    2900:	3f 4f       	sbci	r19, 0xFF	; 255
    2902:	85 e5       	ldi	r24, 0x55	; 85
    2904:	93 e0       	ldi	r25, 0x03	; 3
    2906:	b9 01       	movw	r22, r18
    2908:	0e 94 44 07 	call	0xe88	; 0xe88 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    290c:	ea 81       	ldd	r30, Y+2	; 0x02
    290e:	fb 81       	ldd	r31, Y+3	; 0x03
    2910:	96 89       	ldd	r25, Z+22	; 0x16
    2912:	e0 91 04 03 	lds	r30, 0x0304
    2916:	f0 91 05 03 	lds	r31, 0x0305
    291a:	86 89       	ldd	r24, Z+22	; 0x16
    291c:	98 17       	cp	r25, r24
    291e:	18 f0       	brcs	.+6      	; 0x2926 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2920:	81 e0       	ldi	r24, 0x01	; 1
    2922:	89 83       	std	Y+1, r24	; 0x01
    2924:	01 c0       	rjmp	.+2      	; 0x2928 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2926:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2928:	89 81       	ldd	r24, Y+1	; 0x01
}
    292a:	0f 90       	pop	r0
    292c:	0f 90       	pop	r0
    292e:	0f 90       	pop	r0
    2930:	0f 90       	pop	r0
    2932:	0f 90       	pop	r0
    2934:	cf 91       	pop	r28
    2936:	df 91       	pop	r29
    2938:	08 95       	ret

0000293a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    293a:	df 93       	push	r29
    293c:	cf 93       	push	r28
    293e:	00 d0       	rcall	.+0      	; 0x2940 <vTaskSetTimeOutState+0x6>
    2940:	cd b7       	in	r28, 0x3d	; 61
    2942:	de b7       	in	r29, 0x3e	; 62
    2944:	9a 83       	std	Y+2, r25	; 0x02
    2946:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2948:	80 91 10 03 	lds	r24, 0x0310
    294c:	e9 81       	ldd	r30, Y+1	; 0x01
    294e:	fa 81       	ldd	r31, Y+2	; 0x02
    2950:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2952:	80 91 08 03 	lds	r24, 0x0308
    2956:	90 91 09 03 	lds	r25, 0x0309
    295a:	e9 81       	ldd	r30, Y+1	; 0x01
    295c:	fa 81       	ldd	r31, Y+2	; 0x02
    295e:	92 83       	std	Z+2, r25	; 0x02
    2960:	81 83       	std	Z+1, r24	; 0x01
}
    2962:	0f 90       	pop	r0
    2964:	0f 90       	pop	r0
    2966:	cf 91       	pop	r28
    2968:	df 91       	pop	r29
    296a:	08 95       	ret

0000296c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    296c:	df 93       	push	r29
    296e:	cf 93       	push	r28
    2970:	00 d0       	rcall	.+0      	; 0x2972 <xTaskCheckForTimeOut+0x6>
    2972:	00 d0       	rcall	.+0      	; 0x2974 <xTaskCheckForTimeOut+0x8>
    2974:	0f 92       	push	r0
    2976:	cd b7       	in	r28, 0x3d	; 61
    2978:	de b7       	in	r29, 0x3e	; 62
    297a:	9b 83       	std	Y+3, r25	; 0x03
    297c:	8a 83       	std	Y+2, r24	; 0x02
    297e:	7d 83       	std	Y+5, r23	; 0x05
    2980:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2982:	0f b6       	in	r0, 0x3f	; 63
    2984:	f8 94       	cli
    2986:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2988:	ea 81       	ldd	r30, Y+2	; 0x02
    298a:	fb 81       	ldd	r31, Y+3	; 0x03
    298c:	90 81       	ld	r25, Z
    298e:	80 91 10 03 	lds	r24, 0x0310
    2992:	98 17       	cp	r25, r24
    2994:	71 f0       	breq	.+28     	; 0x29b2 <xTaskCheckForTimeOut+0x46>
    2996:	ea 81       	ldd	r30, Y+2	; 0x02
    2998:	fb 81       	ldd	r31, Y+3	; 0x03
    299a:	21 81       	ldd	r18, Z+1	; 0x01
    299c:	32 81       	ldd	r19, Z+2	; 0x02
    299e:	80 91 08 03 	lds	r24, 0x0308
    29a2:	90 91 09 03 	lds	r25, 0x0309
    29a6:	82 17       	cp	r24, r18
    29a8:	93 07       	cpc	r25, r19
    29aa:	18 f0       	brcs	.+6      	; 0x29b2 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	89 83       	std	Y+1, r24	; 0x01
    29b0:	2f c0       	rjmp	.+94     	; 0x2a10 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    29b2:	20 91 08 03 	lds	r18, 0x0308
    29b6:	30 91 09 03 	lds	r19, 0x0309
    29ba:	ea 81       	ldd	r30, Y+2	; 0x02
    29bc:	fb 81       	ldd	r31, Y+3	; 0x03
    29be:	81 81       	ldd	r24, Z+1	; 0x01
    29c0:	92 81       	ldd	r25, Z+2	; 0x02
    29c2:	28 1b       	sub	r18, r24
    29c4:	39 0b       	sbc	r19, r25
    29c6:	ec 81       	ldd	r30, Y+4	; 0x04
    29c8:	fd 81       	ldd	r31, Y+5	; 0x05
    29ca:	80 81       	ld	r24, Z
    29cc:	91 81       	ldd	r25, Z+1	; 0x01
    29ce:	28 17       	cp	r18, r24
    29d0:	39 07       	cpc	r19, r25
    29d2:	e0 f4       	brcc	.+56     	; 0x2a0c <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    29d4:	ec 81       	ldd	r30, Y+4	; 0x04
    29d6:	fd 81       	ldd	r31, Y+5	; 0x05
    29d8:	40 81       	ld	r20, Z
    29da:	51 81       	ldd	r21, Z+1	; 0x01
    29dc:	ea 81       	ldd	r30, Y+2	; 0x02
    29de:	fb 81       	ldd	r31, Y+3	; 0x03
    29e0:	21 81       	ldd	r18, Z+1	; 0x01
    29e2:	32 81       	ldd	r19, Z+2	; 0x02
    29e4:	80 91 08 03 	lds	r24, 0x0308
    29e8:	90 91 09 03 	lds	r25, 0x0309
    29ec:	b9 01       	movw	r22, r18
    29ee:	68 1b       	sub	r22, r24
    29f0:	79 0b       	sbc	r23, r25
    29f2:	cb 01       	movw	r24, r22
    29f4:	84 0f       	add	r24, r20
    29f6:	95 1f       	adc	r25, r21
    29f8:	ec 81       	ldd	r30, Y+4	; 0x04
    29fa:	fd 81       	ldd	r31, Y+5	; 0x05
    29fc:	91 83       	std	Z+1, r25	; 0x01
    29fe:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2a00:	8a 81       	ldd	r24, Y+2	; 0x02
    2a02:	9b 81       	ldd	r25, Y+3	; 0x03
    2a04:	0e 94 9d 14 	call	0x293a	; 0x293a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2a08:	19 82       	std	Y+1, r1	; 0x01
    2a0a:	02 c0       	rjmp	.+4      	; 0x2a10 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2a0c:	81 e0       	ldi	r24, 0x01	; 1
    2a0e:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2a10:	0f 90       	pop	r0
    2a12:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2a14:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a16:	0f 90       	pop	r0
    2a18:	0f 90       	pop	r0
    2a1a:	0f 90       	pop	r0
    2a1c:	0f 90       	pop	r0
    2a1e:	0f 90       	pop	r0
    2a20:	cf 91       	pop	r28
    2a22:	df 91       	pop	r29
    2a24:	08 95       	ret

00002a26 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2a26:	df 93       	push	r29
    2a28:	cf 93       	push	r28
    2a2a:	cd b7       	in	r28, 0x3d	; 61
    2a2c:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2a2e:	81 e0       	ldi	r24, 0x01	; 1
    2a30:	80 93 0f 03 	sts	0x030F, r24
}
    2a34:	cf 91       	pop	r28
    2a36:	df 91       	pop	r29
    2a38:	08 95       	ret

00002a3a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2a3a:	df 93       	push	r29
    2a3c:	cf 93       	push	r28
    2a3e:	00 d0       	rcall	.+0      	; 0x2a40 <prvIdleTask+0x6>
    2a40:	cd b7       	in	r28, 0x3d	; 61
    2a42:	de b7       	in	r29, 0x3e	; 62
    2a44:	9a 83       	std	Y+2, r25	; 0x02
    2a46:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2a48:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    2a4c:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
    2a50:	fb cf       	rjmp	.-10     	; 0x2a48 <prvIdleTask+0xe>

00002a52 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2a52:	0f 93       	push	r16
    2a54:	1f 93       	push	r17
    2a56:	df 93       	push	r29
    2a58:	cf 93       	push	r28
    2a5a:	cd b7       	in	r28, 0x3d	; 61
    2a5c:	de b7       	in	r29, 0x3e	; 62
    2a5e:	29 97       	sbiw	r28, 0x09	; 9
    2a60:	0f b6       	in	r0, 0x3f	; 63
    2a62:	f8 94       	cli
    2a64:	de bf       	out	0x3e, r29	; 62
    2a66:	0f be       	out	0x3f, r0	; 63
    2a68:	cd bf       	out	0x3d, r28	; 61
    2a6a:	9a 83       	std	Y+2, r25	; 0x02
    2a6c:	89 83       	std	Y+1, r24	; 0x01
    2a6e:	7c 83       	std	Y+4, r23	; 0x04
    2a70:	6b 83       	std	Y+3, r22	; 0x03
    2a72:	4d 83       	std	Y+5, r20	; 0x05
    2a74:	3f 83       	std	Y+7, r19	; 0x07
    2a76:	2e 83       	std	Y+6, r18	; 0x06
    2a78:	19 87       	std	Y+9, r17	; 0x09
    2a7a:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2a7c:	89 81       	ldd	r24, Y+1	; 0x01
    2a7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a80:	49 96       	adiw	r24, 0x19	; 25
    2a82:	2b 81       	ldd	r18, Y+3	; 0x03
    2a84:	3c 81       	ldd	r19, Y+4	; 0x04
    2a86:	b9 01       	movw	r22, r18
    2a88:	48 e0       	ldi	r20, 0x08	; 8
    2a8a:	50 e0       	ldi	r21, 0x00	; 0
    2a8c:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2a90:	e9 81       	ldd	r30, Y+1	; 0x01
    2a92:	fa 81       	ldd	r31, Y+2	; 0x02
    2a94:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2a96:	8d 81       	ldd	r24, Y+5	; 0x05
    2a98:	85 30       	cpi	r24, 0x05	; 5
    2a9a:	10 f0       	brcs	.+4      	; 0x2aa0 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2a9c:	84 e0       	ldi	r24, 0x04	; 4
    2a9e:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa4:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa6:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2aa8:	89 81       	ldd	r24, Y+1	; 0x01
    2aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    2aac:	02 96       	adiw	r24, 0x02	; 2
    2aae:	0e 94 34 07 	call	0xe68	; 0xe68 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2ab2:	89 81       	ldd	r24, Y+1	; 0x01
    2ab4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab6:	0c 96       	adiw	r24, 0x0c	; 12
    2ab8:	0e 94 34 07 	call	0xe68	; 0xe68 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2abc:	e9 81       	ldd	r30, Y+1	; 0x01
    2abe:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac0:	89 81       	ldd	r24, Y+1	; 0x01
    2ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac4:	91 87       	std	Z+9, r25	; 0x09
    2ac6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2ac8:	8d 81       	ldd	r24, Y+5	; 0x05
    2aca:	28 2f       	mov	r18, r24
    2acc:	30 e0       	ldi	r19, 0x00	; 0
    2ace:	85 e0       	ldi	r24, 0x05	; 5
    2ad0:	90 e0       	ldi	r25, 0x00	; 0
    2ad2:	82 1b       	sub	r24, r18
    2ad4:	93 0b       	sbc	r25, r19
    2ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    2ada:	95 87       	std	Z+13, r25	; 0x0d
    2adc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2ade:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae2:	89 81       	ldd	r24, Y+1	; 0x01
    2ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae6:	93 8b       	std	Z+19, r25	; 0x13
    2ae8:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2aea:	29 96       	adiw	r28, 0x09	; 9
    2aec:	0f b6       	in	r0, 0x3f	; 63
    2aee:	f8 94       	cli
    2af0:	de bf       	out	0x3e, r29	; 62
    2af2:	0f be       	out	0x3f, r0	; 63
    2af4:	cd bf       	out	0x3d, r28	; 61
    2af6:	cf 91       	pop	r28
    2af8:	df 91       	pop	r29
    2afa:	1f 91       	pop	r17
    2afc:	0f 91       	pop	r16
    2afe:	08 95       	ret

00002b00 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2b00:	df 93       	push	r29
    2b02:	cf 93       	push	r28
    2b04:	0f 92       	push	r0
    2b06:	cd b7       	in	r28, 0x3d	; 61
    2b08:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2b0a:	19 82       	std	Y+1, r1	; 0x01
    2b0c:	13 c0       	rjmp	.+38     	; 0x2b34 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2b0e:	89 81       	ldd	r24, Y+1	; 0x01
    2b10:	28 2f       	mov	r18, r24
    2b12:	30 e0       	ldi	r19, 0x00	; 0
    2b14:	c9 01       	movw	r24, r18
    2b16:	88 0f       	add	r24, r24
    2b18:	99 1f       	adc	r25, r25
    2b1a:	88 0f       	add	r24, r24
    2b1c:	99 1f       	adc	r25, r25
    2b1e:	88 0f       	add	r24, r24
    2b20:	99 1f       	adc	r25, r25
    2b22:	82 0f       	add	r24, r18
    2b24:	93 1f       	adc	r25, r19
    2b26:	8e 5e       	subi	r24, 0xEE	; 238
    2b28:	9c 4f       	sbci	r25, 0xFC	; 252
    2b2a:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2b2e:	89 81       	ldd	r24, Y+1	; 0x01
    2b30:	8f 5f       	subi	r24, 0xFF	; 255
    2b32:	89 83       	std	Y+1, r24	; 0x01
    2b34:	89 81       	ldd	r24, Y+1	; 0x01
    2b36:	85 30       	cpi	r24, 0x05	; 5
    2b38:	50 f3       	brcs	.-44     	; 0x2b0e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2b3a:	8f e3       	ldi	r24, 0x3F	; 63
    2b3c:	93 e0       	ldi	r25, 0x03	; 3
    2b3e:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2b42:	88 e4       	ldi	r24, 0x48	; 72
    2b44:	93 e0       	ldi	r25, 0x03	; 3
    2b46:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2b4a:	85 e5       	ldi	r24, 0x55	; 85
    2b4c:	93 e0       	ldi	r25, 0x03	; 3
    2b4e:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2b52:	8e e5       	ldi	r24, 0x5E	; 94
    2b54:	93 e0       	ldi	r25, 0x03	; 3
    2b56:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2b5a:	8f e3       	ldi	r24, 0x3F	; 63
    2b5c:	93 e0       	ldi	r25, 0x03	; 3
    2b5e:	90 93 52 03 	sts	0x0352, r25
    2b62:	80 93 51 03 	sts	0x0351, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2b66:	88 e4       	ldi	r24, 0x48	; 72
    2b68:	93 e0       	ldi	r25, 0x03	; 3
    2b6a:	90 93 54 03 	sts	0x0354, r25
    2b6e:	80 93 53 03 	sts	0x0353, r24
}
    2b72:	0f 90       	pop	r0
    2b74:	cf 91       	pop	r28
    2b76:	df 91       	pop	r29
    2b78:	08 95       	ret

00002b7a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2b7a:	df 93       	push	r29
    2b7c:	cf 93       	push	r28
    2b7e:	00 d0       	rcall	.+0      	; 0x2b80 <prvCheckTasksWaitingTermination+0x6>
    2b80:	0f 92       	push	r0
    2b82:	cd b7       	in	r28, 0x3d	; 61
    2b84:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2b86:	80 91 06 03 	lds	r24, 0x0306
    2b8a:	88 23       	and	r24, r24
    2b8c:	71 f1       	breq	.+92     	; 0x2bea <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2b8e:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2b92:	80 91 5e 03 	lds	r24, 0x035E
    2b96:	1b 82       	std	Y+3, r1	; 0x03
    2b98:	88 23       	and	r24, r24
    2b9a:	11 f4       	brne	.+4      	; 0x2ba0 <prvCheckTasksWaitingTermination+0x26>
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2ba0:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2ba4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba6:	88 23       	and	r24, r24
    2ba8:	01 f5       	brne	.+64     	; 0x2bea <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2baa:	0f b6       	in	r0, 0x3f	; 63
    2bac:	f8 94       	cli
    2bae:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2bb0:	e0 91 63 03 	lds	r30, 0x0363
    2bb4:	f0 91 64 03 	lds	r31, 0x0364
    2bb8:	86 81       	ldd	r24, Z+6	; 0x06
    2bba:	97 81       	ldd	r25, Z+7	; 0x07
    2bbc:	9a 83       	std	Y+2, r25	; 0x02
    2bbe:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2bc0:	89 81       	ldd	r24, Y+1	; 0x01
    2bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2bc4:	02 96       	adiw	r24, 0x02	; 2
    2bc6:	0e 94 fc 07 	call	0xff8	; 0xff8 <vListRemove>
					--uxCurrentNumberOfTasks;
    2bca:	80 91 07 03 	lds	r24, 0x0307
    2bce:	81 50       	subi	r24, 0x01	; 1
    2bd0:	80 93 07 03 	sts	0x0307, r24
					--uxTasksDeleted;
    2bd4:	80 91 06 03 	lds	r24, 0x0306
    2bd8:	81 50       	subi	r24, 0x01	; 1
    2bda:	80 93 06 03 	sts	0x0306, r24
				}
				taskEXIT_CRITICAL();
    2bde:	0f 90       	pop	r0
    2be0:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2be2:	89 81       	ldd	r24, Y+1	; 0x01
    2be4:	9a 81       	ldd	r25, Y+2	; 0x02
    2be6:	0e 94 94 16 	call	0x2d28	; 0x2d28 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2bea:	0f 90       	pop	r0
    2bec:	0f 90       	pop	r0
    2bee:	0f 90       	pop	r0
    2bf0:	cf 91       	pop	r28
    2bf2:	df 91       	pop	r29
    2bf4:	08 95       	ret

00002bf6 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2bf6:	df 93       	push	r29
    2bf8:	cf 93       	push	r28
    2bfa:	00 d0       	rcall	.+0      	; 0x2bfc <prvAddCurrentTaskToDelayedList+0x6>
    2bfc:	cd b7       	in	r28, 0x3d	; 61
    2bfe:	de b7       	in	r29, 0x3e	; 62
    2c00:	9a 83       	std	Y+2, r25	; 0x02
    2c02:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2c04:	e0 91 04 03 	lds	r30, 0x0304
    2c08:	f0 91 05 03 	lds	r31, 0x0305
    2c0c:	89 81       	ldd	r24, Y+1	; 0x01
    2c0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c10:	93 83       	std	Z+3, r25	; 0x03
    2c12:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2c14:	20 91 08 03 	lds	r18, 0x0308
    2c18:	30 91 09 03 	lds	r19, 0x0309
    2c1c:	89 81       	ldd	r24, Y+1	; 0x01
    2c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c20:	82 17       	cp	r24, r18
    2c22:	93 07       	cpc	r25, r19
    2c24:	70 f4       	brcc	.+28     	; 0x2c42 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c26:	80 91 53 03 	lds	r24, 0x0353
    2c2a:	90 91 54 03 	lds	r25, 0x0354
    2c2e:	20 91 04 03 	lds	r18, 0x0304
    2c32:	30 91 05 03 	lds	r19, 0x0305
    2c36:	2e 5f       	subi	r18, 0xFE	; 254
    2c38:	3f 4f       	sbci	r19, 0xFF	; 255
    2c3a:	b9 01       	movw	r22, r18
    2c3c:	0e 94 90 07 	call	0xf20	; 0xf20 <vListInsert>
    2c40:	1e c0       	rjmp	.+60     	; 0x2c7e <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c42:	40 91 51 03 	lds	r20, 0x0351
    2c46:	50 91 52 03 	lds	r21, 0x0352
    2c4a:	80 91 04 03 	lds	r24, 0x0304
    2c4e:	90 91 05 03 	lds	r25, 0x0305
    2c52:	9c 01       	movw	r18, r24
    2c54:	2e 5f       	subi	r18, 0xFE	; 254
    2c56:	3f 4f       	sbci	r19, 0xFF	; 255
    2c58:	ca 01       	movw	r24, r20
    2c5a:	b9 01       	movw	r22, r18
    2c5c:	0e 94 90 07 	call	0xf20	; 0xf20 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2c60:	20 91 6b 00 	lds	r18, 0x006B
    2c64:	30 91 6c 00 	lds	r19, 0x006C
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6c:	82 17       	cp	r24, r18
    2c6e:	93 07       	cpc	r25, r19
    2c70:	30 f4       	brcc	.+12     	; 0x2c7e <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2c72:	89 81       	ldd	r24, Y+1	; 0x01
    2c74:	9a 81       	ldd	r25, Y+2	; 0x02
    2c76:	90 93 6c 00 	sts	0x006C, r25
    2c7a:	80 93 6b 00 	sts	0x006B, r24
		}
	}
}
    2c7e:	0f 90       	pop	r0
    2c80:	0f 90       	pop	r0
    2c82:	cf 91       	pop	r28
    2c84:	df 91       	pop	r29
    2c86:	08 95       	ret

00002c88 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2c88:	df 93       	push	r29
    2c8a:	cf 93       	push	r28
    2c8c:	cd b7       	in	r28, 0x3d	; 61
    2c8e:	de b7       	in	r29, 0x3e	; 62
    2c90:	28 97       	sbiw	r28, 0x08	; 8
    2c92:	0f b6       	in	r0, 0x3f	; 63
    2c94:	f8 94       	cli
    2c96:	de bf       	out	0x3e, r29	; 62
    2c98:	0f be       	out	0x3f, r0	; 63
    2c9a:	cd bf       	out	0x3d, r28	; 61
    2c9c:	9c 83       	std	Y+4, r25	; 0x04
    2c9e:	8b 83       	std	Y+3, r24	; 0x03
    2ca0:	7e 83       	std	Y+6, r23	; 0x06
    2ca2:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2ca4:	81 e2       	ldi	r24, 0x21	; 33
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pvPortMalloc>
    2cac:	9a 83       	std	Y+2, r25	; 0x02
    2cae:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2cb0:	89 81       	ldd	r24, Y+1	; 0x01
    2cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cb4:	00 97       	sbiw	r24, 0x00	; 0
    2cb6:	69 f1       	breq	.+90     	; 0x2d12 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    2cba:	9e 81       	ldd	r25, Y+6	; 0x06
    2cbc:	00 97       	sbiw	r24, 0x00	; 0
    2cbe:	39 f4       	brne	.+14     	; 0x2cce <prvAllocateTCBAndStack+0x46>
    2cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc4:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pvPortMalloc>
    2cc8:	98 87       	std	Y+8, r25	; 0x08
    2cca:	8f 83       	std	Y+7, r24	; 0x07
    2ccc:	04 c0       	rjmp	.+8      	; 0x2cd6 <prvAllocateTCBAndStack+0x4e>
    2cce:	8d 81       	ldd	r24, Y+5	; 0x05
    2cd0:	9e 81       	ldd	r25, Y+6	; 0x06
    2cd2:	98 87       	std	Y+8, r25	; 0x08
    2cd4:	8f 83       	std	Y+7, r24	; 0x07
    2cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cda:	8f 81       	ldd	r24, Y+7	; 0x07
    2cdc:	98 85       	ldd	r25, Y+8	; 0x08
    2cde:	90 8f       	std	Z+24, r25	; 0x18
    2ce0:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2ce2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce6:	87 89       	ldd	r24, Z+23	; 0x17
    2ce8:	90 8d       	ldd	r25, Z+24	; 0x18
    2cea:	00 97       	sbiw	r24, 0x00	; 0
    2cec:	39 f4       	brne	.+14     	; 0x2cfc <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2cee:	89 81       	ldd	r24, Y+1	; 0x01
    2cf0:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf2:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vPortFree>
			pxNewTCB = NULL;
    2cf6:	1a 82       	std	Y+2, r1	; 0x02
    2cf8:	19 82       	std	Y+1, r1	; 0x01
    2cfa:	0b c0       	rjmp	.+22     	; 0x2d12 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2cfc:	e9 81       	ldd	r30, Y+1	; 0x01
    2cfe:	fa 81       	ldd	r31, Y+2	; 0x02
    2d00:	87 89       	ldd	r24, Z+23	; 0x17
    2d02:	90 8d       	ldd	r25, Z+24	; 0x18
    2d04:	2b 81       	ldd	r18, Y+3	; 0x03
    2d06:	3c 81       	ldd	r19, Y+4	; 0x04
    2d08:	65 ea       	ldi	r22, 0xA5	; 165
    2d0a:	70 e0       	ldi	r23, 0x00	; 0
    2d0c:	a9 01       	movw	r20, r18
    2d0e:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <memset>
		}
	}

	return pxNewTCB;
    2d12:	89 81       	ldd	r24, Y+1	; 0x01
    2d14:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d16:	28 96       	adiw	r28, 0x08	; 8
    2d18:	0f b6       	in	r0, 0x3f	; 63
    2d1a:	f8 94       	cli
    2d1c:	de bf       	out	0x3e, r29	; 62
    2d1e:	0f be       	out	0x3f, r0	; 63
    2d20:	cd bf       	out	0x3d, r28	; 61
    2d22:	cf 91       	pop	r28
    2d24:	df 91       	pop	r29
    2d26:	08 95       	ret

00002d28 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2d28:	df 93       	push	r29
    2d2a:	cf 93       	push	r28
    2d2c:	00 d0       	rcall	.+0      	; 0x2d2e <prvDeleteTCB+0x6>
    2d2e:	cd b7       	in	r28, 0x3d	; 61
    2d30:	de b7       	in	r29, 0x3e	; 62
    2d32:	9a 83       	std	Y+2, r25	; 0x02
    2d34:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2d36:	e9 81       	ldd	r30, Y+1	; 0x01
    2d38:	fa 81       	ldd	r31, Y+2	; 0x02
    2d3a:	87 89       	ldd	r24, Z+23	; 0x17
    2d3c:	90 8d       	ldd	r25, Z+24	; 0x18
    2d3e:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vPortFree>
		vPortFree( pxTCB );
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	9a 81       	ldd	r25, Y+2	; 0x02
    2d46:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vPortFree>
	}
    2d4a:	0f 90       	pop	r0
    2d4c:	0f 90       	pop	r0
    2d4e:	cf 91       	pop	r28
    2d50:	df 91       	pop	r29
    2d52:	08 95       	ret

00002d54 <memcpy>:
    2d54:	fb 01       	movw	r30, r22
    2d56:	dc 01       	movw	r26, r24
    2d58:	02 c0       	rjmp	.+4      	; 0x2d5e <memcpy+0xa>
    2d5a:	01 90       	ld	r0, Z+
    2d5c:	0d 92       	st	X+, r0
    2d5e:	41 50       	subi	r20, 0x01	; 1
    2d60:	50 40       	sbci	r21, 0x00	; 0
    2d62:	d8 f7       	brcc	.-10     	; 0x2d5a <memcpy+0x6>
    2d64:	08 95       	ret

00002d66 <memset>:
    2d66:	dc 01       	movw	r26, r24
    2d68:	01 c0       	rjmp	.+2      	; 0x2d6c <memset+0x6>
    2d6a:	6d 93       	st	X+, r22
    2d6c:	41 50       	subi	r20, 0x01	; 1
    2d6e:	50 40       	sbci	r21, 0x00	; 0
    2d70:	e0 f7       	brcc	.-8      	; 0x2d6a <memset+0x4>
    2d72:	08 95       	ret

00002d74 <strncpy>:
    2d74:	fb 01       	movw	r30, r22
    2d76:	dc 01       	movw	r26, r24
    2d78:	41 50       	subi	r20, 0x01	; 1
    2d7a:	50 40       	sbci	r21, 0x00	; 0
    2d7c:	48 f0       	brcs	.+18     	; 0x2d90 <strncpy+0x1c>
    2d7e:	01 90       	ld	r0, Z+
    2d80:	0d 92       	st	X+, r0
    2d82:	00 20       	and	r0, r0
    2d84:	c9 f7       	brne	.-14     	; 0x2d78 <strncpy+0x4>
    2d86:	01 c0       	rjmp	.+2      	; 0x2d8a <strncpy+0x16>
    2d88:	1d 92       	st	X+, r1
    2d8a:	41 50       	subi	r20, 0x01	; 1
    2d8c:	50 40       	sbci	r21, 0x00	; 0
    2d8e:	e0 f7       	brcc	.-8      	; 0x2d88 <strncpy+0x14>
    2d90:	08 95       	ret

00002d92 <_exit>:
    2d92:	f8 94       	cli

00002d94 <__stop_program>:
    2d94:	ff cf       	rjmp	.-2      	; 0x2d94 <__stop_program>
